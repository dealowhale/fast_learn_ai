## 6.1.2 Agent智能体技术

Agent智能体技术代表了AI从被动响应向主动行动的重要转变。与传统的问答式AI不同，Agent具备感知环境、制定计划、执行行动和学习改进的能力，能够在复杂环境中自主完成任务。

### 技术概述

Agent智能体是一个能够感知环境并采取行动以实现目标的自主系统。它结合了大语言模型的推理能力、工具使用能力和环境交互能力，形成了一个完整的智能决策系统。

```python
# Agent智能体核心架构演示
import json
import time
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

class AgentState(Enum):
    """Agent状态枚举"""
    IDLE = "idle"
    THINKING = "thinking"
    PLANNING = "planning"
    EXECUTING = "executing"
    LEARNING = "learning"
    ERROR = "error"

@dataclass
class Task:
    """任务数据结构"""
    id: str
    description: str
    priority: int
    deadline: Optional[datetime] = None
    status: str = "pending"
    result: Optional[Any] = None

@dataclass
class Action:
    """行动数据结构"""
    name: str
    parameters: Dict[str, Any]
    expected_outcome: str
    execution_time: Optional[datetime] = None
    result: Optional[Any] = None

class IntelligentAgent:
    """智能Agent基础框架"""
    
    def __init__(self, name: str, capabilities: List[str]):
        self.name = name
        self.capabilities = capabilities
        self.state = AgentState.IDLE
        self.memory = {
            'short_term': [],  # 短期记忆
            'long_term': {},   # 长期记忆
            'episodic': []     # 情节记忆
        }
        self.tools = self._initialize_tools()
        self.task_queue = []
        self.execution_history = []
        
    def _initialize_tools(self) -> Dict[str, callable]:
        """初始化工具集"""
        return {
            'web_search': self._web_search,
            'file_operation': self._file_operation,
            'calculation': self._calculation,
            'data_analysis': self._data_analysis,
            'communication': self._communication
        }
    
    def perceive_environment(self) -> Dict[str, Any]:
        """感知环境"""
        print(f"🔍 {self.name} 正在感知环境...")
        
        # 模拟环境感知
        environment = {
            'timestamp': datetime.now(),
            'available_resources': {
                'cpu_usage': 45.2,
                'memory_usage': 67.8,
                'network_status': 'connected',
                'disk_space': '85% free'
            },
            'external_events': [
                {'type': 'new_email', 'priority': 'medium'},
                {'type': 'system_update', 'priority': 'low'},
                {'type': 'user_request', 'priority': 'high'}
            ],
            'context_information': {
                'current_projects': ['project_a', 'project_b'],
                'active_users': 3,
                'pending_tasks': len(self.task_queue)
            }
        }
        
        # 更新短期记忆
        self.memory['short_term'].append({
            'type': 'perception',
            'data': environment,
            'timestamp': datetime.now()
        })
        
        return environment
    
    def reason_and_plan(self, task: Task) -> List[Action]:
        """推理和规划"""
        print(f"🧠 {self.name} 正在为任务 '{task.description}' 制定计划...")
        self.state = AgentState.PLANNING
        
        # 分析任务复杂度
        complexity = self._analyze_task_complexity(task)
        
        # 生成行动计划
        if complexity == 'simple':
            plan = self._create_simple_plan(task)
        elif complexity == 'medium':
            plan = self._create_medium_plan(task)
        else:
            plan = self._create_complex_plan(task)
        
        print(f"📋 生成了 {len(plan)} 个行动步骤")
        for i, action in enumerate(plan, 1):
            print(f"   {i}. {action.name}: {action.expected_outcome}")
        
        return plan
    
    def _analyze_task_complexity(self, task: Task) -> str:
        """分析任务复杂度"""
        # 简化的复杂度分析
        keywords = task.description.lower().split()
        
        complex_indicators = ['analyze', 'research', 'compare', 'optimize', 'design']
        medium_indicators = ['create', 'update', 'modify', 'process']
        
        if any(word in keywords for word in complex_indicators):
            return 'complex'
        elif any(word in keywords for word in medium_indicators):
            return 'medium'
        else:
            return 'simple'
    
    def _create_simple_plan(self, task: Task) -> List[Action]:
        """创建简单任务计划"""
        return [
            Action(
                name="direct_execution",
                parameters={'task': task.description},
                expected_outcome="完成任务"
            )
        ]
    
    def _create_medium_plan(self, task: Task) -> List[Action]:
        """创建中等复杂度任务计划"""
        return [
            Action(
                name="gather_information",
                parameters={'topic': task.description},
                expected_outcome="收集相关信息"
            ),
            Action(
                name="process_data",
                parameters={'data_source': 'gathered_info'},
                expected_outcome="处理和分析数据"
            ),
            Action(
                name="generate_result",
                parameters={'processed_data': 'analysis_result'},
                expected_outcome="生成最终结果"
            )
        ]
    
    def _create_complex_plan(self, task: Task) -> List[Action]:
        """创建复杂任务计划"""
        return [
            Action(
                name="task_decomposition",
                parameters={'main_task': task.description},
                expected_outcome="将任务分解为子任务"
            ),
            Action(
                name="research_phase",
                parameters={'research_topics': 'subtasks'},
                expected_outcome="深入研究各个方面"
            ),
            Action(
                name="synthesis_phase",
                parameters={'research_results': 'findings'},
                expected_outcome="综合分析结果"
            ),
            Action(
                name="validation_phase",
                parameters={'synthesis_result': 'conclusions'},
                expected_outcome="验证和优化结果"
            ),
            Action(
                name="final_delivery",
                parameters={'validated_result': 'final_output'},
                expected_outcome="交付最终成果"
            )
        ]
    
    def execute_action(self, action: Action) -> Any:
        """执行行动"""
        print(f"⚡ 执行行动: {action.name}")
        self.state = AgentState.EXECUTING
        action.execution_time = datetime.now()
        
        try:
            # 根据行动类型选择合适的工具
            if action.name in self.tools:
                result = self.tools[action.name](action.parameters)
            else:
                result = self._generic_execution(action)
            
            action.result = result
            
            # 记录执行历史
            self.execution_history.append({
                'action': action,
                'timestamp': datetime.now(),
                'success': True
            })
            
            print(f"✅ 行动完成: {action.expected_outcome}")
            return result
            
        except Exception as e:
            print(f"❌ 行动失败: {str(e)}")
            self.state = AgentState.ERROR
            self.execution_history.append({
                'action': action,
                'timestamp': datetime.now(),
                'success': False,
                'error': str(e)
            })
            return None
    
    def _generic_execution(self, action: Action) -> str:
        """通用执行方法"""
        # 模拟执行过程
        time.sleep(0.5)  # 模拟执行时间
        return f"已执行 {action.name}，参数: {action.parameters}"
    
    def learn_from_experience(self, task: Task, actions: List[Action], outcome: Any):
        """从经验中学习"""
        print(f"📚 {self.name} 正在从执行经验中学习...")
        self.state = AgentState.LEARNING
        
        # 分析执行效果
        success_rate = sum(1 for record in self.execution_history 
                          if record['success']) / len(self.execution_history)
        
        # 提取经验教训
        lessons = {
            'task_type': self._analyze_task_complexity(task),
            'success_rate': success_rate,
            'effective_actions': [action.name for action in actions if action.result],
            'execution_time': sum((record['timestamp'] - actions[0].execution_time).total_seconds() 
                                for record in self.execution_history[-len(actions):]),
            'improvement_suggestions': self._generate_improvements(actions)
        }
        
        # 更新长期记忆
        task_category = self._categorize_task(task)
        if task_category not in self.memory['long_term']:
            self.memory['long_term'][task_category] = []
        
        self.memory['long_term'][task_category].append(lessons)
        
        print(f"📈 学习成果: 成功率 {success_rate:.2%}, 有效行动 {len(lessons['effective_actions'])} 个")
        
        return lessons
    
    def _categorize_task(self, task: Task) -> str:
        """任务分类"""
        keywords = task.description.lower()
        
        if 'data' in keywords or 'analysis' in keywords:
            return 'data_processing'
        elif 'research' in keywords or 'information' in keywords:
            return 'information_gathering'
        elif 'create' in keywords or 'generate' in keywords:
            return 'content_creation'
        else:
            return 'general_task'
    
    def _generate_improvements(self, actions: List[Action]) -> List[str]:
        """生成改进建议"""
        suggestions = []
        
        # 分析失败的行动
        failed_actions = [action for action in actions if not action.result]
        if failed_actions:
            suggestions.append(f"优化 {len(failed_actions)} 个失败行动的执行策略")
        
        # 分析执行时间
        if len(actions) > 3:
            suggestions.append("考虑并行执行部分独立行动以提高效率")
        
        # 基于历史经验
        if len(self.execution_history) > 10:
            recent_success_rate = sum(1 for record in self.execution_history[-10:] 
                                    if record['success']) / 10
            if recent_success_rate < 0.8:
                suggestions.append("需要改进行动规划和执行策略")
        
        return suggestions if suggestions else ["当前执行策略表现良好"]
    
    # 工具方法实现
    def _web_search(self, params: Dict[str, Any]) -> str:
        """网络搜索工具"""
        query = params.get('query', '')
        return f"搜索结果: 找到关于 '{query}' 的相关信息"
    
    def _file_operation(self, params: Dict[str, Any]) -> str:
        """文件操作工具"""
        operation = params.get('operation', 'read')
        filename = params.get('filename', 'unknown')
        return f"文件操作: {operation} {filename} 完成"
    
    def _calculation(self, params: Dict[str, Any]) -> str:
        """计算工具"""
        expression = params.get('expression', '1+1')
        return f"计算结果: {expression} = 2"  # 简化示例
    
    def _data_analysis(self, params: Dict[str, Any]) -> str:
        """数据分析工具"""
        data_type = params.get('data_type', 'unknown')
        return f"数据分析: 已分析 {data_type} 类型数据"
    
    def _communication(self, params: Dict[str, Any]) -> str:
        """通信工具"""
        message = params.get('message', '')
        recipient = params.get('recipient', 'user')
        return f"消息发送: 已向 {recipient} 发送消息"
    
    def run_task(self, task: Task) -> Any:
        """运行完整任务流程"""
        print(f"\n🚀 开始执行任务: {task.description}")
        print("=" * 50)
        
        try:
            # 1. 感知环境
            environment = self.perceive_environment()
            
            # 2. 推理和规划
            plan = self.reason_and_plan(task)
            
            # 3. 执行行动
            results = []
            for action in plan:
                result = self.execute_action(action)
                results.append(result)
                
                # 检查是否需要调整计划
                if not result and action.name != plan[-1].name:
                    print("⚠️ 检测到执行问题，调整后续计划...")
                    # 这里可以实现动态规划调整逻辑
            
            # 4. 学习和改进
            final_result = results[-1] if results else None
            lessons = self.learn_from_experience(task, plan, final_result)
            
            # 5. 更新任务状态
            task.status = "completed" if final_result else "failed"
            task.result = final_result
            
            self.state = AgentState.IDLE
            print(f"\n🎯 任务完成: {task.status}")
            
            return final_result
            
        except Exception as e:
            print(f"\n💥 任务执行异常: {str(e)}")
            task.status = "error"
            self.state = AgentState.ERROR
            return None

# Agent使用演示
if __name__ == "__main__":
    # 创建智能Agent
    agent = IntelligentAgent(
        name="DataAnalyst-Agent",
        capabilities=["data_analysis", "research", "reporting"]
    )
    
    # 创建测试任务
    tasks = [
        Task(
            id="task_001",
            description="分析用户行为数据并生成报告",
            priority=1
        ),
        Task(
            id="task_002", 
            description="搜索最新的AI技术趋势",
            priority=2
        ),
        Task(
            id="task_003",
            description="创建项目进度总结",
            priority=3
        )
    ]
    
    # 执行任务
    for task in tasks:
        result = agent.run_task(task)
        print(f"任务结果: {result}\n")
    
    # 显示Agent学习成果
    print("\n📊 Agent学习成果总结:")
    print(f"执行历史记录: {len(agent.execution_history)} 条")
    print(f"长期记忆类别: {list(agent.memory['long_term'].keys())}")
    print(f"当前状态: {agent.state.value}")
```

### Agent架构设计模式

#### 1. ReAct (Reasoning + Acting) 模式

```python
class ReActAgent:
    """ReAct模式Agent实现"""
    
    def __init__(self, llm_model, tools):
        self.llm = llm_model
        self.tools = tools
        self.thought_history = []
        self.action_history = []
        
    def solve_problem(self, problem: str, max_iterations: int = 10):
        """使用ReAct模式解决问题"""
        print(f"🎯 问题: {problem}")
        print("=" * 60)
        
        context = f"问题: {problem}\n\n"
        
        for iteration in range(max_iterations):
            print(f"\n🔄 迭代 {iteration + 1}:")
            
            # Reasoning: 思考下一步
            thought = self._generate_thought(context)
            self.thought_history.append(thought)
            context += f"思考 {iteration + 1}: {thought}\n"
            print(f"💭 思考: {thought}")
            
            # Acting: 决定行动
            action = self._decide_action(context)
            
            if action['type'] == 'final_answer':
                print(f"✅ 最终答案: {action['content']}")
                return action['content']
            
            # 执行行动
            action_result = self._execute_action(action)
            self.action_history.append((action, action_result))
            context += f"行动 {iteration + 1}: {action['type']}({action.get('parameters', '')})\n"
            context += f"观察 {iteration + 1}: {action_result}\n\n"
            
            print(f"⚡ 行动: {action['type']}")
            print(f"📋 结果: {action_result}")
            
            # 检查是否解决问题
            if self._is_problem_solved(context):
                final_answer = self._generate_final_answer(context)
                print(f"\n🎉 问题已解决: {final_answer}")
                return final_answer
        
        print("\n⚠️ 达到最大迭代次数，未能完全解决问题")
        return self._generate_partial_answer(context)
    
    def _generate_thought(self, context: str) -> str:
        """生成思考内容"""
        # 模拟LLM生成思考
        thoughts = [
            "我需要分析这个问题的关键要素",
            "让我考虑可能的解决方案",
            "我应该收集更多信息来支持我的推理",
            "基于目前的信息，我可以得出一些初步结论",
            "我需要验证我的假设是否正确"
        ]
        
        # 根据上下文选择合适的思考
        if "问题:" in context and len(self.thought_history) == 0:
            return "我需要分析这个问题的关键要素和可能的解决路径"
        elif len(self.action_history) == 0:
            return "让我先收集一些基础信息来更好地理解问题"
        else:
            return thoughts[len(self.thought_history) % len(thoughts)]
    
    def _decide_action(self, context: str) -> Dict[str, Any]:
        """决定下一步行动"""
        # 简化的行动决策逻辑
        if "搜索" in context or "查找" in context:
            return {
                'type': 'search',
                'parameters': {'query': '相关信息'},
                'reason': '需要搜索相关信息'
            }
        elif "计算" in context or "数学" in context:
            return {
                'type': 'calculate',
                'parameters': {'expression': '数学表达式'},
                'reason': '需要进行数值计算'
            }
        elif len(self.action_history) >= 3:
            return {
                'type': 'final_answer',
                'content': '基于收集的信息和分析，我的答案是...',
                'reason': '已收集足够信息，可以给出答案'
            }
        else:
            return {
                'type': 'analyze',
                'parameters': {'target': '问题要素'},
                'reason': '需要深入分析问题'
            }
    
    def _execute_action(self, action: Dict[str, Any]) -> str:
        """执行行动"""
        action_type = action['type']
        
        if action_type == 'search':
            return f"搜索到关于 '{action['parameters']['query']}' 的相关信息"
        elif action_type == 'calculate':
            return f"计算结果: {action['parameters']['expression']} = 42"
        elif action_type == 'analyze':
            return f"分析 '{action['parameters']['target']}' 得到深入见解"
        else:
            return f"执行了 {action_type} 操作"
    
    def _is_problem_solved(self, context: str) -> bool:
        """判断问题是否已解决"""
        # 简化的判断逻辑
        return len(self.action_history) >= 2 and "信息" in context
    
    def _generate_final_answer(self, context: str) -> str:
        """生成最终答案"""
        return "基于分析和收集的信息，问题的答案是综合考虑各种因素后得出的结论"
    
    def _generate_partial_answer(self, context: str) -> str:
        """生成部分答案"""
        return "虽然未能完全解决，但基于目前的分析可以提供部分见解"

# ReAct模式演示
react_agent = ReActAgent(llm_model="gpt-4", tools=["search", "calculate", "analyze"])

# 测试问题
test_problems = [
    "如何提高网站的用户转化率？",
    "分析当前市场上AI芯片的竞争格局",
    "设计一个高效的数据处理流程"
]

for problem in test_problems:
    print(f"\n{'='*80}")
    answer = react_agent.solve_problem(problem, max_iterations=5)
    print(f"\n📝 问题总结: {problem}")
    print(f"🎯 解决方案: {answer}")
```

#### 2. 多Agent协作系统

```python
class MultiAgentSystem:
    """多Agent协作系统"""
    
    def __init__(self):
        self.agents = {}
        self.communication_log = []
        self.task_assignments = {}
        self.collaboration_history = []
        
    def register_agent(self, agent_id: str, agent: IntelligentAgent, specialties: List[str]):
        """注册Agent"""
        self.agents[agent_id] = {
            'agent': agent,
            'specialties': specialties,
            'status': 'available',
            'current_task': None,
            'performance_score': 1.0
        }
        print(f"✅ Agent {agent_id} 已注册，专长: {', '.join(specialties)}")
    
    def assign_collaborative_task(self, task_description: str, required_skills: List[str]):
        """分配协作任务"""
        print(f"\n🎯 协作任务: {task_description}")
        print(f"📋 需要技能: {', '.join(required_skills)}")
        print("=" * 60)
        
        # 1. 任务分解
        subtasks = self._decompose_task(task_description, required_skills)
        
        # 2. Agent匹配和分配
        assignments = self._assign_agents_to_subtasks(subtasks)
        
        # 3. 协作执行
        results = self._execute_collaborative_task(assignments)
        
        # 4. 结果整合
        final_result = self._integrate_results(results)
        
        # 5. 协作评估
        self._evaluate_collaboration(assignments, results)
        
        return final_result
    
    def _decompose_task(self, task_description: str, required_skills: List[str]) -> List[Dict]:
        """任务分解"""
        print("\n🔧 任务分解阶段:")
        
        # 基于技能需求分解任务
        subtasks = []
        
        if 'research' in required_skills:
            subtasks.append({
                'id': 'research_subtask',
                'description': f"研究与 '{task_description}' 相关的信息",
                'required_skill': 'research',
                'priority': 1,
                'dependencies': []
            })
        
        if 'analysis' in required_skills:
            subtasks.append({
                'id': 'analysis_subtask',
                'description': f"分析 '{task_description}' 的关键要素",
                'required_skill': 'analysis',
                'priority': 2,
                'dependencies': ['research_subtask'] if 'research' in required_skills else []
            })
        
        if 'design' in required_skills:
            subtasks.append({
                'id': 'design_subtask',
                'description': f"设计 '{task_description}' 的解决方案",
                'required_skill': 'design',
                'priority': 3,
                'dependencies': ['analysis_subtask'] if 'analysis' in required_skills else []
            })
        
        if 'implementation' in required_skills:
            subtasks.append({
                'id': 'implementation_subtask',
                'description': f"实施 '{task_description}' 的解决方案",
                'required_skill': 'implementation',
                'priority': 4,
                'dependencies': ['design_subtask'] if 'design' in required_skills else []
            })
        
        for subtask in subtasks:
            print(f"   📌 {subtask['id']}: {subtask['description']}")
        
        return subtasks
    
    def _assign_agents_to_subtasks(self, subtasks: List[Dict]) -> Dict[str, str]:
        """为子任务分配Agent"""
        print("\n👥 Agent分配阶段:")
        
        assignments = {}
        
        for subtask in subtasks:
            required_skill = subtask['required_skill']
            
            # 找到具备相应技能的Agent
            suitable_agents = []
            for agent_id, agent_info in self.agents.items():
                if (required_skill in agent_info['specialties'] and 
                    agent_info['status'] == 'available'):
                    suitable_agents.append((agent_id, agent_info['performance_score']))
            
            if suitable_agents:
                # 选择性能最好的Agent
                best_agent = max(suitable_agents, key=lambda x: x[1])[0]
                assignments[subtask['id']] = best_agent
                self.agents[best_agent]['status'] = 'assigned'
                self.agents[best_agent]['current_task'] = subtask['id']
                
                print(f"   ✅ {subtask['id']} -> {best_agent} (技能: {required_skill})")
            else:
                print(f"   ❌ 未找到适合 {subtask['id']} 的Agent (需要技能: {required_skill})")
        
        return assignments
    
    def _execute_collaborative_task(self, assignments: Dict[str, str]) -> Dict[str, Any]:
        """执行协作任务"""
        print("\n⚡ 协作执行阶段:")
        
        results = {}
        execution_order = self._determine_execution_order(assignments)
        
        for subtask_id in execution_order:
            if subtask_id in assignments:
                agent_id = assignments[subtask_id]
                agent = self.agents[agent_id]['agent']
                
                print(f"\n🔄 执行 {subtask_id} (Agent: {agent_id})")
                
                # 创建子任务
                subtask = Task(
                    id=subtask_id,
                    description=f"执行子任务: {subtask_id}",
                    priority=1
                )
                
                # 执行任务
                result = agent.run_task(subtask)
                results[subtask_id] = {
                    'agent_id': agent_id,
                    'result': result,
                    'timestamp': datetime.now()
                }
                
                # 更新Agent状态
                self.agents[agent_id]['status'] = 'available'
                self.agents[agent_id]['current_task'] = None
                
                # 记录协作日志
                self.communication_log.append({
                    'type': 'task_completion',
                    'agent_id': agent_id,
                    'subtask_id': subtask_id,
                    'timestamp': datetime.now()
                })
        
        return results
    
    def _determine_execution_order(self, assignments: Dict[str, str]) -> List[str]:
        """确定执行顺序"""
        # 简化的依赖关系处理
        order = ['research_subtask', 'analysis_subtask', 'design_subtask', 'implementation_subtask']
        return [task for task in order if task in assignments]
    
    def _integrate_results(self, results: Dict[str, Any]) -> str:
        """整合结果"""
        print("\n🔗 结果整合阶段:")
        
        integrated_result = "协作任务完成结果:\n"
        
        for subtask_id, result_info in results.items():
            agent_id = result_info['agent_id']
            result = result_info['result']
            integrated_result += f"- {subtask_id} (by {agent_id}): {result}\n"
        
        integrated_result += "\n所有子任务已成功完成，目标达成。"
        
        print(f"📋 整合结果: {integrated_result}")
        return integrated_result
    
    def _evaluate_collaboration(self, assignments: Dict[str, str], results: Dict[str, Any]):
        """评估协作效果"""
        print("\n📊 协作评估阶段:")
        
        # 计算协作指标
        total_tasks = len(assignments)
        successful_tasks = len([r for r in results.values() if r['result']])
        success_rate = successful_tasks / total_tasks if total_tasks > 0 else 0
        
        # 更新Agent性能分数
        for subtask_id, agent_id in assignments.items():
            if subtask_id in results and results[subtask_id]['result']:
                # 成功完成任务，提升性能分数
                self.agents[agent_id]['performance_score'] *= 1.1
            else:
                # 任务失败，降低性能分数
                self.agents[agent_id]['performance_score'] *= 0.9
        
        # 记录协作历史
        collaboration_record = {
            'timestamp': datetime.now(),
            'participants': list(assignments.values()),
            'success_rate': success_rate,
            'total_tasks': total_tasks,
            'successful_tasks': successful_tasks
        }
        self.collaboration_history.append(collaboration_record)
        
        print(f"   成功率: {success_rate:.2%}")
        print(f"   参与Agent: {', '.join(set(assignments.values()))}")
        print(f"   完成任务: {successful_tasks}/{total_tasks}")
    
    def get_system_status(self) -> Dict[str, Any]:
        """获取系统状态"""
        return {
            'total_agents': len(self.agents),
            'available_agents': len([a for a in self.agents.values() if a['status'] == 'available']),
            'active_tasks': len([a for a in self.agents.values() if a['current_task']]),
            'communication_events': len(self.communication_log),
            'collaboration_sessions': len(self.collaboration_history),
            'average_performance': sum(a['performance_score'] for a in self.agents.values()) / len(self.agents) if self.agents else 0
        }

# 多Agent系统演示
if __name__ == "__main__":
    # 创建多Agent系统
    mas = MultiAgentSystem()
    
    # 创建专业化Agent
    research_agent = IntelligentAgent("ResearchBot", ["research", "information_gathering"])
    analysis_agent = IntelligentAgent("AnalysisBot", ["analysis", "data_processing"])
    design_agent = IntelligentAgent("DesignBot", ["design", "planning"])
    impl_agent = IntelligentAgent("ImplBot", ["implementation", "execution"])
    
    # 注册Agent
    mas.register_agent("researcher", research_agent, ["research"])
    mas.register_agent("analyst", analysis_agent, ["analysis"])
    mas.register_agent("designer", design_agent, ["design"])
    mas.register_agent("implementer", impl_agent, ["implementation"])
    
    # 执行协作任务
    collaborative_tasks = [
        {
            'description': '开发智能客服系统',
            'skills': ['research', 'analysis', 'design', 'implementation']
        },
        {
            'description': '优化数据处理流程',
            'skills': ['analysis', 'design']
        }
    ]
    
    for task in collaborative_tasks:
        result = mas.assign_collaborative_task(task['description'], task['skills'])
        print(f"\n🏆 最终结果: {result}")
        print("\n" + "="*80)
    
    # 显示系统状态
    status = mas.get_system_status()
    print("\n📈 系统状态总结:")
    for key, value in status.items():
        print(f"   {key}: {value}")
```

### 工具使用与环境交互

```python
class ToolUsingAgent:
    """工具使用Agent"""
    
    def __init__(self, name: str):
        self.name = name
        self.available_tools = self._initialize_tools()
        self.tool_usage_history = []
        self.environment_state = {}
        
    def _initialize_tools(self) -> Dict[str, Dict]:
        """初始化工具库"""
        return {
            'web_browser': {
                'description': '网页浏览和信息搜索',
                'functions': ['search', 'navigate', 'extract_text'],
                'parameters': ['url', 'query', 'selector'],
                'cost': 1
            },
            'code_executor': {
                'description': '代码执行和测试',
                'functions': ['run_python', 'run_javascript', 'test_code'],
                'parameters': ['code', 'language', 'test_cases'],
                'cost': 2
            },
            'file_manager': {
                'description': '文件系统操作',
                'functions': ['read_file', 'write_file', 'list_directory'],
                'parameters': ['path', 'content', 'mode'],
                'cost': 1
            },
            'api_client': {
                'description': 'API调用和数据获取',
                'functions': ['get_request', 'post_request', 'parse_response'],
                'parameters': ['endpoint', 'headers', 'payload'],
                'cost': 3
            },
            'data_processor': {
                'description': '数据处理和分析',
                'functions': ['clean_data', 'analyze_data', 'visualize_data'],
                'parameters': ['data', 'method', 'options'],
                'cost': 2
            }
        }
    
    def select_appropriate_tool(self, task_description: str, context: Dict[str, Any]) -> str:
        """选择合适的工具"""
        print(f"🔍 为任务选择工具: {task_description}")
        
        # 基于任务描述的关键词匹配
        task_lower = task_description.lower()
        
        tool_scores = {}
        for tool_name, tool_info in self.available_tools.items():
            score = 0
            
            # 基于描述匹配
            if any(word in task_lower for word in tool_info['description'].lower().split()):
                score += 3
            
            # 基于功能匹配
            for function in tool_info['functions']:
                if any(word in task_lower for word in function.split('_')):
                    score += 2
            
            # 考虑成本因素（成本越低越好）
            score -= tool_info['cost'] * 0.5
            
            tool_scores[tool_name] = score
        
        # 选择得分最高的工具
        best_tool = max(tool_scores.items(), key=lambda x: x[1])
        
        print(f"   选择工具: {best_tool[0]} (得分: {best_tool[1]:.1f})")
        print(f"   工具描述: {self.available_tools[best_tool[0]]['description']}")
        
        return best_tool[0]
    
    def use_tool(self, tool_name: str, function: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """使用工具"""
        print(f"\n🛠️ 使用工具: {tool_name}.{function}")
        print(f"   参数: {parameters}")
        
        if tool_name not in self.available_tools:
            return {'success': False, 'error': f'工具 {tool_name} 不存在'}
        
        tool_info = self.available_tools[tool_name]
        
        if function not in tool_info['functions']:
            return {'success': False, 'error': f'工具 {tool_name} 不支持功能 {function}'}
        
        # 模拟工具使用
        result = self._simulate_tool_usage(tool_name, function, parameters)
        
        # 记录使用历史
        usage_record = {
            'timestamp': datetime.now(),
            'tool': tool_name,
            'function': function,
            'parameters': parameters,
            'result': result,
            'cost': tool_info['cost']
        }
        self.tool_usage_history.append(usage_record)
        
        print(f"   结果: {result['message']}")
        return result
    
    def _simulate_tool_usage(self, tool_name: str, function: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """模拟工具使用"""
        # 根据工具类型模拟不同的结果
        if tool_name == 'web_browser':
            if function == 'search':
                return {
                    'success': True,
                    'message': f"搜索 '{parameters.get('query', '')}' 找到 15 个相关结果",
                    'data': ['结果1', '结果2', '结果3']
                }
            elif function == 'navigate':
                return {
                    'success': True,
                    'message': f"成功访问 {parameters.get('url', '')}",
                    'data': {'title': '网页标题', 'content': '网页内容摘要'}
                }
        
        elif tool_name == 'code_executor':
            if function == 'run_python':
                return {
                    'success': True,
                    'message': '代码执行成功',
                    'data': {'output': '执行结果', 'execution_time': 0.5}
                }
        
        elif tool_name == 'file_manager':
            if function == 'read_file':
                return {
                    'success': True,
                    'message': f"成功读取文件 {parameters.get('path', '')}",
                    'data': {'content': '文件内容', 'size': 1024}
                }
        
        elif tool_name == 'api_client':
            if function == 'get_request':
                return {
                    'success': True,
                    'message': f"API请求成功: {parameters.get('endpoint', '')}",
                    'data': {'status_code': 200, 'response': {'key': 'value'}}
                }
        
        elif tool_name == 'data_processor':
            if function == 'analyze_data':
                return {
                    'success': True,
                    'message': '数据分析完成',
                    'data': {'mean': 42.5, 'std': 12.3, 'count': 1000}
                }
        
        # 默认返回
        return {
            'success': True,
            'message': f'工具 {tool_name} 的 {function} 功能执行完成',
            'data': {}
        }
    
    def interact_with_environment(self, environment_type: str, action: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """与环境交互"""
        print(f"\n🌍 环境交互: {environment_type} - {action}")
        
        # 模拟不同类型的环境交互
        if environment_type == 'file_system':
            return self._interact_with_filesystem(action, parameters)
        elif environment_type == 'web_service':
            return self._interact_with_webservice(action, parameters)
        elif environment_type == 'database':
            return self._interact_with_database(action, parameters)
        elif environment_type == 'cloud_platform':
            return self._interact_with_cloud(action, parameters)
        else:
            return {'success': False, 'error': f'不支持的环境类型: {environment_type}'}
    
    def _interact_with_filesystem(self, action: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """文件系统交互"""
        if action == 'create_directory':
            return {'success': True, 'message': f"创建目录: {params.get('path', '')}"}
        elif action == 'delete_file':
            return {'success': True, 'message': f"删除文件: {params.get('path', '')}"}
        elif action == 'copy_file':
            return {'success': True, 'message': f"复制文件: {params.get('source', '')} -> {params.get('dest', '')}"}
        else:
            return {'success': False, 'error': f'不支持的文件系统操作: {action}'}
    
    def _interact_with_webservice(self, action: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Web服务交互"""
        if action == 'send_request':
            return {'success': True, 'message': f"发送请求到: {params.get('url', '')}", 'status_code': 200}
        elif action == 'upload_file':
            return {'success': True, 'message': f"上传文件: {params.get('filename', '')}", 'file_id': 'abc123'}
        else:
            return {'success': False, 'error': f'不支持的Web服务操作: {action}'}
    
    def _interact_with_database(self, action: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """数据库交互"""
        if action == 'query':
            return {'success': True, 'message': '查询执行成功', 'rows': 42}
        elif action == 'insert':
            return {'success': True, 'message': '数据插入成功', 'inserted_id': 123}
        else:
            return {'success': False, 'error': f'不支持的数据库操作: {action}'}
    
    def _interact_with_cloud(self, action: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """云平台交互"""
        if action == 'deploy_service':
            return {'success': True, 'message': '服务部署成功', 'service_url': 'https://service.cloud.com'}
        elif action == 'scale_resources':
            return {'success': True, 'message': f"资源扩展到 {params.get('instances', 1)} 个实例"}
        else:
            return {'success': False, 'error': f'不支持的云平台操作: {action}'}
    
    def execute_complex_workflow(self, workflow_description: str) -> Dict[str, Any]:
        """执行复杂工作流"""
        print(f"\n🔄 执行复杂工作流: {workflow_description}")
        print("=" * 60)
        
        # 工作流步骤
        workflow_steps = [
            {
                'step': 1,
                'description': '信息收集',
                'tool': 'web_browser',
                'function': 'search',
                'params': {'query': workflow_description}
            },
            {
                'step': 2,
                'description': '数据处理',
                'tool': 'data_processor',
                'function': 'analyze_data',
                'params': {'data': 'collected_info'}
            },
            {
                'step': 3,
                'description': '代码生成',
                'tool': 'code_executor',
                'function': 'run_python',
                'params': {'code': 'generated_solution'}
            },
            {
                'step': 4,
                'description': '结果保存',
                'tool': 'file_manager',
                'function': 'write_file',
                'params': {'path': 'result.txt', 'content': 'workflow_result'}
            }
        ]
        
        workflow_results = []
        
        for step in workflow_steps:
            print(f"\n📋 步骤 {step['step']}: {step['description']}")
            
            # 使用工具执行步骤
            result = self.use_tool(
                step['tool'],
                step['function'],
                step['params']
            )
            
            workflow_results.append({
                'step': step['step'],
                'description': step['description'],
                'result': result
            })
            
            # 如果步骤失败，终止工作流
            if not result.get('success', False):
                print(f"❌ 工作流在步骤 {step['step']} 失败")
                break
        
        # 生成工作流总结
        successful_steps = len([r for r in workflow_results if r['result'].get('success', False)])
        total_cost = sum(self.available_tools[step['tool']]['cost'] for step in workflow_steps[:successful_steps])
        
        workflow_summary = {
            'workflow': workflow_description,
            'total_steps': len(workflow_steps),
            'successful_steps': successful_steps,
            'total_cost': total_cost,
            'results': workflow_results,
            'completion_time': datetime.now()
        }
        
        print(f"\n📊 工作流总结:")
        print(f"   成功步骤: {successful_steps}/{len(workflow_steps)}")
        print(f"   总成本: {total_cost}")
        print(f"   完成时间: {workflow_summary['completion_time']}")
        
        return workflow_summary
    
    def get_tool_usage_analytics(self) -> Dict[str, Any]:
        """获取工具使用分析"""
        if not self.tool_usage_history:
            return {'message': '暂无工具使用记录'}
        
        # 统计工具使用情况
        tool_usage_count = {}
        total_cost = 0
        successful_operations = 0
        
        for record in self.tool_usage_history:
            tool = record['tool']
            tool_usage_count[tool] = tool_usage_count.get(tool, 0) + 1
            total_cost += record['cost']
            if record['result'].get('success', False):
                successful_operations += 1
        
        # 计算成功率
        success_rate = successful_operations / len(self.tool_usage_history)
        
        # 找出最常用的工具
        most_used_tool = max(tool_usage_count.items(), key=lambda x: x[1]) if tool_usage_count else None
        
        return {
            'total_operations': len(self.tool_usage_history),
            'successful_operations': successful_operations,
            'success_rate': success_rate,
            'total_cost': total_cost,
            'average_cost': total_cost / len(self.tool_usage_history),
            'tool_usage_count': tool_usage_count,
            'most_used_tool': most_used_tool[0] if most_used_tool else None,
            'unique_tools_used': len(tool_usage_count)
        }

# 工具使用Agent演示
if __name__ == "__main__":
    # 创建工具使用Agent
    tool_agent = ToolUsingAgent("ToolMaster")
    
    # 演示工具选择和使用
    tasks = [
        "搜索人工智能最新发展趋势",
        "分析用户行为数据",
        "执行数据清洗脚本",
        "调用天气API获取信息"
    ]
    
    for task in tasks:
        print(f"\n{'='*60}")
        print(f"🎯 任务: {task}")
        
        # 选择工具
        selected_tool = tool_agent.select_appropriate_tool(task, {})
        
        # 使用工具
        tool_info = tool_agent.available_tools[selected_tool]
        function = tool_info['functions'][0]  # 使用第一个功能
        params = {'query': task} if 'query' in tool_info['parameters'] else {}
        
        result = tool_agent.use_tool(selected_tool, function, params)
    
    # 执行复杂工作流
    print(f"\n{'='*80}")
    workflow_result = tool_agent.execute_complex_workflow("开发智能推荐系统")
    
    # 显示使用分析
    print(f"\n{'='*60}")
    print("📈 工具使用分析:")
    analytics = tool_agent.get_tool_usage_analytics()
    for key, value in analytics.items():
        if key != 'tool_usage_count':
            print(f"   {key}: {value}")
    
    if 'tool_usage_count' in analytics:
        print("   工具使用统计:")
        for tool, count in analytics['tool_usage_count'].items():
            print(f"     {tool}: {count} 次")
```

### 学习与适应机制

```python
class AdaptiveLearningAgent:
    """自适应学习Agent"""
    
    def __init__(self, name: str):
        self.name = name
        self.knowledge_base = {
            'facts': {},           # 事实知识
            'rules': {},           # 规则知识
            'experiences': [],     # 经验知识
            'patterns': {}         # 模式知识
        }
        self.learning_strategies = {
            'reinforcement': self._reinforcement_learning,
            'imitation': self._imitation_learning,
            'exploration': self._exploration_learning,
            'reflection': self._reflection_learning
        }
        self.performance_metrics = {
            'task_success_rate': [],
            'learning_efficiency': [],
            'adaptation_speed': [],
            'knowledge_retention': []
        }
        
    def learn_from_feedback(self, task: str, action: str, outcome: str, feedback: Dict[str, Any]):
        """从反馈中学习"""
        print(f"\n📚 学习反馈: {task}")
        print(f"   行动: {action}")
        print(f"   结果: {outcome}")
        print(f"   反馈: {feedback}")
        
        # 创建经验记录
        experience = {
            'timestamp': datetime.now(),
            'task': task,
            'action': action,
            'outcome': outcome,
            'feedback': feedback,
            'context': self._extract_context(task)
        }
        
        self.knowledge_base['experiences'].append(experience)
        
        # 根据反馈类型选择学习策略
        if feedback.get('type') == 'reward':
            self._reinforcement_learning(experience)
        elif feedback.get('type') == 'demonstration':
            self._imitation_learning(experience)
        elif feedback.get('type') == 'exploration_result':
            self._exploration_learning(experience)
        else:
            self._reflection_learning(experience)
        
        # 更新性能指标
        self._update_performance_metrics(experience)
        
        print(f"✅ 学习完成，知识库更新")
    
    def _extract_context(self, task: str) -> Dict[str, Any]:
        """提取任务上下文"""
        return {
            'task_type': self._classify_task_type(task),
            'complexity': self._estimate_complexity(task),
            'domain': self._identify_domain(task),
            'keywords': task.lower().split()
        }
    
    def _classify_task_type(self, task: str) -> str:
        """分类任务类型"""
        task_lower = task.lower()
        if any(word in task_lower for word in ['analyze', 'analysis']):
            return 'analysis'
        elif any(word in task_lower for word in ['create', 'generate', 'build']):
            return 'creation'
        elif any(word in task_lower for word in ['search', 'find', 'lookup']):
            return 'information_retrieval'
        elif any(word in task_lower for word in ['optimize', 'improve', 'enhance']):
            return 'optimization'
        else:
            return 'general'
    
    def _estimate_complexity(self, task: str) -> str:
        """估计任务复杂度"""
        complexity_indicators = {
            'high': ['complex', 'advanced', 'comprehensive', 'detailed'],
            'medium': ['moderate', 'standard', 'regular', 'typical'],
            'low': ['simple', 'basic', 'easy', 'quick']
        }
        
        task_lower = task.lower()
        for level, indicators in complexity_indicators.items():
            if any(word in task_lower for word in indicators):
                return level
        
        # 基于任务长度估计复杂度
        if len(task.split()) > 10:
            return 'high'
        elif len(task.split()) > 5:
            return 'medium'
        else:
            return 'low'
    
    def _identify_domain(self, task: str) -> str:
        """识别任务领域"""
        domain_keywords = {
            'technology': ['ai', 'machine learning', 'programming', 'software', 'algorithm'],
            'business': ['market', 'sales', 'revenue', 'customer', 'strategy'],
            'science': ['research', 'experiment', 'hypothesis', 'data', 'analysis'],
            'education': ['learning', 'teaching', 'student', 'course', 'knowledge'],
            'healthcare': ['medical', 'health', 'patient', 'diagnosis', 'treatment']
        }
        
        task_lower = task.lower()
        for domain, keywords in domain_keywords.items():
            if any(keyword in task_lower for keyword in keywords):
                return domain
        
        return 'general'
    
    def _reinforcement_learning(self, experience: Dict[str, Any]):
        """强化学习"""
        print("   🎯 应用强化学习策略")
        
        reward = experience['feedback'].get('reward', 0)
        action = experience['action']
        context = experience['context']
        
        # 更新行动价值
        context_key = f"{context['task_type']}_{context['complexity']}"
        
        if context_key not in self.knowledge_base['rules']:
            self.knowledge_base['rules'][context_key] = {}
        
        if action not in self.knowledge_base['rules'][context_key]:
            self.knowledge_base['rules'][context_key][action] = {'value': 0, 'count': 0}
        
        # 更新价值函数（简化的Q-learning）
        current_value = self.knowledge_base['rules'][context_key][action]['value']
        count = self.knowledge_base['rules'][context_key][action]['count']
        
        # 增量更新
        new_value = current_value + (reward - current_value) / (count + 1)
        
        self.knowledge_base['rules'][context_key][action]['value'] = new_value
        self.knowledge_base['rules'][context_key][action]['count'] = count + 1
        
        print(f"      行动 '{action}' 的价值更新: {current_value:.3f} -> {new_value:.3f}")
    
    def _imitation_learning(self, experience: Dict[str, Any]):
        """模仿学习"""
        print("   👥 应用模仿学习策略")
        
        demonstration = experience['feedback'].get('demonstration', {})
        if not demonstration:
            return
        
        # 提取专家行为模式
        expert_action = demonstration.get('action')
        expert_reasoning = demonstration.get('reasoning', '')
        
        if expert_action:
            # 存储专家示例
            context_key = f"{experience['context']['task_type']}_expert"
            
            if context_key not in self.knowledge_base['patterns']:
                self.knowledge_base['patterns'][context_key] = []
            
            pattern = {
                'situation': experience['task'],
                'expert_action': expert_action,
                'reasoning': expert_reasoning,
                'timestamp': datetime.now()
            }
            
            self.knowledge_base['patterns'][context_key].append(pattern)
            
            print(f"      学习专家行为: {expert_action}")
            print(f"      专家推理: {expert_reasoning}")
    
    def _exploration_learning(self, experience: Dict[str, Any]):
        """探索学习"""
        print("   🔍 应用探索学习策略")
        
        # 记录探索结果
        exploration_result = experience['feedback'].get('exploration_result', {})
        
        if exploration_result.get('novel_discovery'):
            # 发现新知识
            discovery = exploration_result['novel_discovery']
            
            fact_key = f"discovery_{len(self.knowledge_base['facts'])}"
            self.knowledge_base['facts'][fact_key] = {
                'content': discovery,
                'confidence': exploration_result.get('confidence', 0.5),
                'source': 'exploration',
                'timestamp': datetime.now()
            }
            
            print(f"      发现新知识: {discovery}")
        
        # 更新探索策略
        if exploration_result.get('effectiveness'):
            effectiveness = exploration_result['effectiveness']
            strategy = experience['action']
            
            strategy_key = f"exploration_{strategy}"
            if strategy_key not in self.knowledge_base['rules']:
                self.knowledge_base['rules'][strategy_key] = {'effectiveness': 0, 'usage_count': 0}
            
            current_eff = self.knowledge_base['rules'][strategy_key]['effectiveness']
            count = self.knowledge_base['rules'][strategy_key]['usage_count']
            
            new_eff = (current_eff * count + effectiveness) / (count + 1)
            
            self.knowledge_base['rules'][strategy_key]['effectiveness'] = new_eff
            self.knowledge_base['rules'][strategy_key]['usage_count'] = count + 1
            
            print(f"      探索策略 '{strategy}' 效果更新: {current_eff:.3f} -> {new_eff:.3f}")
    
    def _reflection_learning(self, experience: Dict[str, Any]):
        """反思学习"""
        print("   🤔 应用反思学习策略")
        
        # 分析经验模式
        similar_experiences = self._find_similar_experiences(experience)
        
        if len(similar_experiences) >= 3:
            # 提取共同模式
            patterns = self._extract_patterns(similar_experiences)
            
            for pattern in patterns:
                pattern_key = f"pattern_{len(self.knowledge_base['patterns'])}"
                self.knowledge_base['patterns'][pattern_key] = {
                    'pattern': pattern,
                    'confidence': self._calculate_pattern_confidence(pattern, similar_experiences),
                    'source': 'reflection',
                    'timestamp': datetime.now()
                }
                
                print(f"      识别模式: {pattern['description']}")
        
        # 反思失败原因
        if experience['outcome'] == 'failure':
            failure_analysis = self._analyze_failure(experience)
            
            failure_key = f"failure_lesson_{len(self.knowledge_base['facts'])}"
            self.knowledge_base['facts'][failure_key] = {
                'content': failure_analysis,
                'type': 'failure_lesson',
                'timestamp': datetime.now()
            }
            
            print(f"      失败分析: {failure_analysis}")
    
    def _find_similar_experiences(self, target_experience: Dict[str, Any]) -> List[Dict[str, Any]]:
        """找到相似经验"""
        similar = []
        target_context = target_experience['context']
        
        for exp in self.knowledge_base['experiences']:
            if exp == target_experience:
                continue
            
            similarity_score = 0
            exp_context = exp['context']
            
            # 计算相似度
            if exp_context['task_type'] == target_context['task_type']:
                similarity_score += 0.4
            if exp_context['complexity'] == target_context['complexity']:
                similarity_score += 0.3
            if exp_context['domain'] == target_context['domain']:
                similarity_score += 0.3
            
            if similarity_score >= 0.6:
                similar.append(exp)
        
        return similar
    
    def _extract_patterns(self, experiences: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """提取经验模式"""
        patterns = []
        
        # 成功模式
        successful_experiences = [exp for exp in experiences if exp['outcome'] == 'success']
        if len(successful_experiences) >= 2:
            common_actions = self._find_common_actions(successful_experiences)
            if common_actions:
                patterns.append({
                    'type': 'success_pattern',
                    'description': f"在类似情况下，{common_actions[0]} 通常导致成功",
                    'actions': common_actions,
                    'success_rate': len(successful_experiences) / len(experiences)
                })
        
        # 失败模式
        failed_experiences = [exp for exp in experiences if exp['outcome'] == 'failure']
        if len(failed_experiences) >= 2:
            common_failures = self._find_common_actions(failed_experiences)
            if common_failures:
                patterns.append({
                    'type': 'failure_pattern',
                    'description': f"避免在类似情况下使用 {common_failures[0]}",
                    'actions': common_failures,
                    'failure_rate': len(failed_experiences) / len(experiences)
                })
        
        return patterns
    
    def _find_common_actions(self, experiences: List[Dict[str, Any]]) -> List[str]:
        """找到共同行动"""
        action_counts = {}
        for exp in experiences:
            action = exp['action']
            action_counts[action] = action_counts.get(action, 0) + 1
        
        # 返回出现频率最高的行动
        if action_counts:
            return [action for action, count in action_counts.items() 
                   if count >= len(experiences) * 0.5]
        return []
    
    def _calculate_pattern_confidence(self, pattern: Dict[str, Any], experiences: List[Dict[str, Any]]) -> float:
        """计算模式置信度"""
        if pattern['type'] == 'success_pattern':
            return pattern['success_rate']
        elif pattern['type'] == 'failure_pattern':
            return pattern['failure_rate']
        else:
            return 0.5
    
    def _analyze_failure(self, experience: Dict[str, Any]) -> str:
        """分析失败原因"""
        failure_reasons = [
            "行动选择不当",
            "上下文理解错误",
            "资源不足",
            "时机不合适",
            "方法不适用"
        ]
        
        # 简化的失败分析
        return f"任务 '{experience['task']}' 失败可能由于: {failure_reasons[0]}"
    
    def _update_performance_metrics(self, experience: Dict[str, Any]):
        """更新性能指标"""
        # 任务成功率
        recent_experiences = self.knowledge_base['experiences'][-10:]  # 最近10次经验
        success_count = len([exp for exp in recent_experiences if exp['outcome'] == 'success'])
        success_rate = success_count / len(recent_experiences) if recent_experiences else 0
        self.performance_metrics['task_success_rate'].append(success_rate)
        
        # 学习效率（知识增长率）
        knowledge_items = (len(self.knowledge_base['facts']) + 
                          len(self.knowledge_base['rules']) + 
                          len(self.knowledge_base['patterns']))
        learning_efficiency = knowledge_items / len(self.knowledge_base['experiences']) if self.knowledge_base['experiences'] else 0
        self.performance_metrics['learning_efficiency'].append(learning_efficiency)
    
    def recommend_action(self, task: str) -> Dict[str, Any]:
        """基于学习经验推荐行动"""
        print(f"\n🎯 为任务推荐行动: {task}")
        
        context = self._extract_context(task)
        context_key = f"{context['task_type']}_{context['complexity']}"
        
        recommendations = []
        
        # 基于规则的推荐
        if context_key in self.knowledge_base['rules']:
            actions = self.knowledge_base['rules'][context_key]
            for action, info in actions.items():
                if info['count'] > 0:  # 有使用经验
                    recommendations.append({
                        'action': action,
                        'confidence': info['value'],
                        'source': 'reinforcement_learning',
                        'usage_count': info['count']
                    })
        
        # 基于模式的推荐
        expert_key = f"{context['task_type']}_expert"
        if expert_key in self.knowledge_base['patterns']:
            expert_patterns = self.knowledge_base['patterns'][expert_key]
            for pattern in expert_patterns[-3:]:  # 最近3个专家示例
                recommendations.append({
                    'action': pattern['expert_action'],
                    'confidence': 0.8,  # 专家示例高置信度
                    'source': 'expert_demonstration',
                    'reasoning': pattern['reasoning']
                })
        
        # 排序推荐
        recommendations.sort(key=lambda x: x['confidence'], reverse=True)
        
        if recommendations:
            best_recommendation = recommendations[0]
            print(f"   推荐行动: {best_recommendation['action']}")
            print(f"   置信度: {best_recommendation['confidence']:.3f}")
            print(f"   来源: {best_recommendation['source']}")
            
            return best_recommendation
        else:
            # 没有相关经验，推荐探索
            exploration_action = self._generate_exploration_action(context)
            print(f"   推荐探索行动: {exploration_action}")
            
            return {
                'action': exploration_action,
                'confidence': 0.3,
                'source': 'exploration',
                'reasoning': '缺乏相关经验，建议探索'
            }
    
    def _generate_exploration_action(self, context: Dict[str, Any]) -> str:
        """生成探索行动"""
        exploration_actions = {
            'analysis': '深入分析问题要素',
            'creation': '尝试创新方法',
            'information_retrieval': '扩大搜索范围',
            'optimization': '测试不同优化策略',
            'general': '采用通用问题解决方法'
        }
        
        return exploration_actions.get(context['task_type'], exploration_actions['general'])
    
    def get_learning_summary(self) -> Dict[str, Any]:
        """获取学习总结"""
        return {
            'total_experiences': len(self.knowledge_base['experiences']),
            'facts_learned': len(self.knowledge_base['facts']),
            'rules_acquired': len(self.knowledge_base['rules']),
            'patterns_identified': len(self.knowledge_base['patterns']),
            'current_success_rate': self.performance_metrics['task_success_rate'][-1] if self.performance_metrics['task_success_rate'] else 0,
            'learning_efficiency': self.performance_metrics['learning_efficiency'][-1] if self.performance_metrics['learning_efficiency'] else 0,
            'knowledge_domains': list(set(exp['context']['domain'] for exp in self.knowledge_base['experiences'])),
            'task_types_handled': list(set(exp['context']['task_type'] for exp in self.knowledge_base['experiences']))
        }

# 自适应学习Agent演示
if __name__ == "__main__":
    # 创建自适应学习Agent
    learning_agent = AdaptiveLearningAgent("AdaptiveBot")
    
    # 模拟学习过程
    learning_scenarios = [
        {
            'task': '分析市场趋势数据',
            'action': '使用统计分析方法',
            'outcome': 'success',
            'feedback': {'type': 'reward', 'reward': 0.8}
        },
        {
            'task': '创建用户界面设计',
            'action': '采用用户中心设计',
            'outcome': 'success',
            'feedback': {
                'type': 'demonstration',
                'demonstration': {
                    'action': '先进行用户研究',
                    'reasoning': '了解用户需求是设计的基础'
                }
            }
        },
        {
            'task': '优化算法性能',
            'action': '随机尝试参数调整',
            'outcome': 'failure',
            'feedback': {'type': 'reflection'}
        },
        {
            'task': '搜索技术文档',
            'action': '使用关键词搜索',
            'outcome': 'success',
            'feedback': {
                'type': 'exploration_result',
                'exploration_result': {
                    'novel_discovery': '发现新的搜索技巧',
                    'confidence': 0.7,
                    'effectiveness': 0.9
                }
            }
        }
    ]
    
    print("🎓 开始自适应学习过程")
    print("=" * 60)
    
    # 执行学习场景
    for i, scenario in enumerate(learning_scenarios, 1):
        print(f"\n📖 学习场景 {i}:")
        learning_agent.learn_from_feedback(
            scenario['task'],
            scenario['action'],
            scenario['outcome'],
            scenario['feedback']
        )
    
    # 测试推荐系统
    print(f"\n{'='*60}")
    print("🤖 测试行动推荐系统")
    
    test_tasks = [
        "分析销售数据趋势",
        "设计移动应用界面",
        "优化数据库查询性能"
    ]
    
    for task in test_tasks:
        recommendation = learning_agent.recommend_action(task)
    
    # 显示学习总结
    print(f"\n{'='*60}")
    print("📊 学习成果总结:")
    summary = learning_agent.get_learning_summary()
    for key, value in summary.items():
        print(f"   {key}: {value}")

## 小结

Agent智能体技术代表了AI从被动响应向主动行动的重要转变。通过本节的学习，你应该了解到：

### 🎯 核心要点
1. **架构设计**：Agent需要感知、推理、行动和学习四个核心能力
2. **协作模式**：多Agent系统能够处理复杂的协作任务
3. **工具使用**：Agent通过工具扩展自身能力边界
4. **学习适应**：自适应学习让Agent不断改进和优化

### 💡 实践建议
1. **从简单开始**：先实现基础的单Agent系统
2. **工具集成**：逐步集成更多实用工具
3. **协作设计**：考虑多Agent协作的场景和机制
4. **持续学习**：实现Agent的学习和适应能力

### 🚀 发展方向
1. **更智能的推理**：结合大模型提升推理能力
2. **更丰富的工具**：集成更多专业工具和API
3. **更好的协作**：优化多Agent协作机制
4. **更强的学习**：实现更高效的学习算法

Agent技术正在快速发展，掌握这一技术将为你在AI应用开发中提供强大的工具。在下一小节中，我们将探讨模型压缩与优化技术。