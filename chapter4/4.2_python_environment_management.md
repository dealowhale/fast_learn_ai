# 4.2 Python环境和依赖管理

在AI开发中，Python环境和依赖管理是确保项目稳定性和可重现性的关键基础。本节将详细介绍如何在Trae IDE中高效管理Python环境，包括虚拟环境创建、依赖包管理、版本控制以及最佳实践。

## 4.2.1 Python虚拟环境管理

### 虚拟环境的重要性

虚拟环境是Python开发的最佳实践，它能够：
- 🔒 **隔离项目依赖** - 避免不同项目间的包冲突
- 📦 **版本控制** - 确保每个项目使用特定版本的包
- 🚀 **部署一致性** - 保证开发和生产环境的一致性
- 🛡️ **系统保护** - 避免污染系统Python环境

### 在Trae中创建和管理虚拟环境

```python
# Python虚拟环境管理工具
import os
import sys
import subprocess
import json
from pathlib import Path
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from datetime import datetime

class TraeEnvironmentManager:
    """Trae环境管理器"""
    
    def __init__(self, project_root=None):
        self.project_root = Path(project_root) if project_root else Path.cwd()
        self.venv_dir = self.project_root / '.venv'
        self.requirements_file = self.project_root / 'requirements.txt'
        self.env_config_file = self.project_root / 'environment.json'
        
    def create_virtual_environment(self, python_version=None):
        """创建虚拟环境"""
        print("=== 创建Python虚拟环境 ===")
        
        # 检查Python版本
        if python_version:
            python_cmd = f'python{python_version}'
        else:
            python_cmd = 'python'
            
        try:
            # 创建虚拟环境
            cmd = [python_cmd, '-m', 'venv', str(self.venv_dir)]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            print(f"✅ 虚拟环境创建成功: {self.venv_dir}")
            
            # 获取Python版本信息
            python_info = self.get_python_info()
            
            # 保存环境配置
            self.save_environment_config(python_info)
            
            # 升级pip
            self.upgrade_pip()
            
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"❌ 虚拟环境创建失败: {e}")
            return False
    
    def get_python_info(self):
        """获取Python环境信息"""
        if os.name == 'nt':  # Windows
            python_exe = self.venv_dir / 'Scripts' / 'python.exe'
        else:  # Unix/Linux/macOS
            python_exe = self.venv_dir / 'bin' / 'python'
            
        try:
            # 获取Python版本
            version_result = subprocess.run(
                [str(python_exe), '--version'], 
                capture_output=True, text=True, check=True
            )
            
            # 获取pip版本
            pip_result = subprocess.run(
                [str(python_exe), '-m', 'pip', '--version'], 
                capture_output=True, text=True, check=True
            )
            
            return {
                'python_version': version_result.stdout.strip(),
                'pip_version': pip_result.stdout.strip(),
                'python_executable': str(python_exe),
                'created_at': datetime.now().isoformat(),
                'platform': sys.platform
            }
            
        except subprocess.CalledProcessError as e:
            print(f"⚠️ 获取Python信息失败: {e}")
            return {}
    
    def save_environment_config(self, python_info):
        """保存环境配置"""
        config = {
            'project_name': self.project_root.name,
            'environment_path': str(self.venv_dir),
            'python_info': python_info,
            'requirements_file': str(self.requirements_file),
            'created_at': datetime.now().isoformat()
        }
        
        with open(self.env_config_file, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2, ensure_ascii=False)
            
        print(f"📝 环境配置已保存: {self.env_config_file}")
    
    def upgrade_pip(self):
        """升级pip到最新版本"""
        print("\n=== 升级pip ===")
        
        if os.name == 'nt':  # Windows
            pip_exe = self.venv_dir / 'Scripts' / 'pip.exe'
        else:  # Unix/Linux/macOS
            pip_exe = self.venv_dir / 'bin' / 'pip'
            
        try:
            cmd = [str(pip_exe), 'install', '--upgrade', 'pip']
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            print("✅ pip升级成功")
            
        except subprocess.CalledProcessError as e:
            print(f"⚠️ pip升级失败: {e}")
    
    def activate_environment(self):
        """激活虚拟环境 (返回激活脚本路径)"""
        if os.name == 'nt':  # Windows
            activate_script = self.venv_dir / 'Scripts' / 'activate.bat'
        else:  # Unix/Linux/macOS
            activate_script = self.venv_dir / 'bin' / 'activate'
            
        if activate_script.exists():
            print(f"\n🔧 激活虚拟环境:")
            if os.name == 'nt':
                print(f"   {activate_script}")
            else:
                print(f"   source {activate_script}")
            return str(activate_script)
        else:
            print("❌ 虚拟环境不存在，请先创建")
            return None
    
    def list_installed_packages(self):
        """列出已安装的包"""
        print("\n=== 已安装的Python包 ===")
        
        if os.name == 'nt':  # Windows
            pip_exe = self.venv_dir / 'Scripts' / 'pip.exe'
        else:  # Unix/Linux/macOS
            pip_exe = self.venv_dir / 'bin' / 'pip'
            
        try:
            cmd = [str(pip_exe), 'list', '--format=json']
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            packages = json.loads(result.stdout)
            
            if packages:
                # 创建包信息DataFrame
                df = pd.DataFrame(packages)
                print(f"\n📦 共安装了 {len(packages)} 个包:")
                
                # 按名称排序并显示
                df_sorted = df.sort_values('name')
                for _, package in df_sorted.iterrows():
                    print(f"  • {package['name']} ({package['version']})")
                
                return packages
            else:
                print("📦 暂无已安装的包")
                return []
                
        except subprocess.CalledProcessError as e:
            print(f"❌ 获取包列表失败: {e}")
            return []
        except json.JSONDecodeError as e:
            print(f"❌ 解析包信息失败: {e}")
            return []

# 创建环境管理器实例
env_manager = TraeEnvironmentManager()

# 演示虚拟环境创建
print("🚀 开始创建Python虚拟环境...")
if env_manager.create_virtual_environment():
    # 激活环境
    activate_script = env_manager.activate_environment()
    
    # 列出已安装包
    packages = env_manager.list_installed_packages()
    
    print("\n✨ 虚拟环境创建完成！")
else:
    print("❌ 虚拟环境创建失败")
```

### 虚拟环境最佳实践

```python
# 虚拟环境最佳实践指南
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Rectangle

def create_venv_best_practices_guide():
    """创建虚拟环境最佳实践指南"""
    print("=== Python虚拟环境最佳实践 ===")
    
    # 创建最佳实践可视化
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('Python虚拟环境管理最佳实践', fontsize=16, fontweight='bold')
    
    # 1. 环境命名规范
    naming_conventions = {
        '项目名称': 85,
        '版本标识': 75,
        '环境类型': 70,
        '日期标记': 60,
        '随机命名': 20
    }
    
    names = list(naming_conventions.keys())
    scores = list(naming_conventions.values())
    colors = ['#4CAF50', '#8BC34A', '#FFC107', '#FF9800', '#F44336']
    
    bars = ax1.barh(names, scores, color=colors, alpha=0.8)
    ax1.set_xlabel('推荐度评分', fontsize=11)
    ax1.set_title('虚拟环境命名规范', fontsize=12, fontweight='bold')
    ax1.set_xlim(0, 100)
    
    # 添加评分标签
    for bar, score in zip(bars, scores):
        width = bar.get_width()
        ax1.text(width + 2, bar.get_y() + bar.get_height()/2,
                 f'{score}%', ha='left', va='center', fontweight='bold')
    
    # 2. 依赖管理策略对比
    strategies = ['requirements.txt', 'Pipfile', 'poetry.lock', 'conda.yaml']
    metrics = {
        '易用性': [90, 75, 70, 80],
        '功能完整性': [60, 85, 95, 90],
        '生态兼容性': [95, 80, 75, 70],
        '学习成本': [95, 70, 60, 65]
    }
    
    x_pos = np.arange(len(strategies))
    width = 0.2
    colors_metrics = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']
    
    for i, (metric, values) in enumerate(metrics.items()):
        ax2.bar(x_pos + i * width, values, width, 
                label=metric, color=colors_metrics[i], alpha=0.8)
    
    ax2.set_xlabel('依赖管理工具', fontsize=11)
    ax2.set_ylabel('评分 (1-100)', fontsize=11)
    ax2.set_title('依赖管理策略对比', fontsize=12, fontweight='bold')
    ax2.set_xticks(x_pos + width * 1.5)
    ax2.set_xticklabels(strategies, rotation=45, ha='right')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    # 3. 环境生命周期管理
    lifecycle_stages = ['创建', '开发', '测试', '部署', '维护', '清理']
    importance_scores = [95, 90, 85, 95, 70, 60]
    complexity_scores = [30, 60, 70, 80, 50, 20]
    
    ax3.scatter(complexity_scores, importance_scores, 
               s=[200, 250, 220, 280, 180, 150], 
               c=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'],
               alpha=0.7, edgecolors='black', linewidth=2)
    
    # 添加阶段标签
    for i, stage in enumerate(lifecycle_stages):
        ax3.annotate(stage, (complexity_scores[i], importance_scores[i]), 
                    xytext=(5, 5), textcoords='offset points', 
                    fontsize=10, fontweight='bold')
    
    ax3.set_xlabel('复杂度评分', fontsize=11)
    ax3.set_ylabel('重要性评分', fontsize=11)
    ax3.set_title('环境生命周期管理', fontsize=12, fontweight='bold')
    ax3.grid(True, alpha=0.3)
    ax3.set_xlim(10, 90)
    ax3.set_ylim(50, 100)
    
    # 4. 常见问题解决方案
    problems = ['包冲突', '版本不兼容', '环境污染', '依赖缺失', '权限问题']
    solution_effectiveness = [90, 85, 95, 80, 70]
    occurrence_frequency = [60, 70, 40, 80, 30]
    
    # 创建气泡图
    bubble_sizes = [freq * 5 for freq in occurrence_frequency]  # 调整气泡大小
    colors_problems = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7']
    
    scatter = ax4.scatter(occurrence_frequency, solution_effectiveness, 
                         s=bubble_sizes, c=colors_problems, alpha=0.6, 
                         edgecolors='black', linewidth=1)
    
    # 添加问题标签
    for i, problem in enumerate(problems):
        ax4.annotate(problem, (occurrence_frequency[i], solution_effectiveness[i]), 
                    xytext=(5, 5), textcoords='offset points', 
                    fontsize=9, fontweight='bold')
    
    ax4.set_xlabel('问题发生频率 (%)', fontsize=11)
    ax4.set_ylabel('解决方案有效性 (%)', fontsize=11)
    ax4.set_title('常见问题与解决方案', fontsize=12, fontweight='bold')
    ax4.grid(True, alpha=0.3)
    ax4.set_xlim(20, 90)
    ax4.set_ylim(60, 100)
    
    plt.tight_layout()
    plt.show()
    
    # 输出最佳实践建议
    print_best_practices()

def print_best_practices():
    """输出最佳实践建议"""
    print("\n=== 虚拟环境最佳实践建议 ===")
    
    practices = {
        '🏗️ 环境创建': [
            '每个项目使用独立的虚拟环境',
            '使用有意义的环境名称',
            '记录Python版本要求',
            '及时升级pip到最新版本'
        ],
        '📦 依赖管理': [
            '使用requirements.txt固定版本',
            '区分开发和生产依赖',
            '定期更新依赖包版本',
            '避免安装不必要的包'
        ],
        '🔧 日常维护': [
            '定期清理未使用的环境',
            '备份重要的环境配置',
            '使用版本控制管理配置文件',
            '文档化环境设置步骤'
        ],
        '🚀 部署准备': [
            '确保requirements.txt完整',
            '测试环境重建流程',
            '验证跨平台兼容性',
            '准备环境迁移脚本'
        ]
    }
    
    for category, practice_list in practices.items():
        print(f"\n{category}:")
        for practice in practice_list:
            print(f"  • {practice}")

# 执行最佳实践指南创建
create_venv_best_practices_guide()
```

## 4.2.2 依赖包管理和版本控制

### requirements.txt 管理

```python
# 依赖包管理工具
import subprocess
import json
import re
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

class DependencyManager:
    """依赖包管理器"""
    
    def __init__(self, project_root=None):
        self.project_root = Path(project_root) if project_root else Path.cwd()
        self.requirements_file = self.project_root / 'requirements.txt'
        self.dev_requirements_file = self.project_root / 'requirements-dev.txt'
        self.lock_file = self.project_root / 'requirements.lock'
        
    def generate_requirements(self, include_versions=True, dev_only=False):
        """生成requirements.txt文件"""
        print("=== 生成依赖文件 ===")
        
        try:
            # 获取已安装包列表
            cmd = ['pip', 'freeze']
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            installed_packages = result.stdout.strip().split('\n')
            
            # 过滤和分类包
            production_packages = []
            dev_packages = []
            
            # 开发工具包列表
            dev_tools = {
                'pytest', 'pytest-cov', 'black', 'flake8', 'mypy', 
                'jupyter', 'notebook', 'ipython', 'sphinx', 'twine',
                'pre-commit', 'isort', 'bandit', 'safety'
            }
            
            for package in installed_packages:
                if package.strip():
                    package_name = package.split('==')[0].lower()
                    
                    if any(dev_tool in package_name for dev_tool in dev_tools):
                        dev_packages.append(package)
                    else:
                        production_packages.append(package)
            
            # 写入生产依赖
            if not dev_only:
                with open(self.requirements_file, 'w', encoding='utf-8') as f:
                    f.write("# 生产环境依赖\n")
                    f.write(f"# 生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                    
                    # 按类别组织依赖
                    categorized_deps = self.categorize_dependencies(production_packages)
                    
                    for category, packages in categorized_deps.items():
                        if packages:
                            f.write(f"# {category}\n")
                            for package in sorted(packages):
                                f.write(f"{package}\n")
                            f.write("\n")
                
                print(f"✅ 生产依赖文件已生成: {self.requirements_file}")
                print(f"   包含 {len(production_packages)} 个包")
            
            # 写入开发依赖
            if dev_packages:
                with open(self.dev_requirements_file, 'w', encoding='utf-8') as f:
                    f.write("# 开发环境依赖\n")
                    f.write(f"# 生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                    f.write("-r requirements.txt\n\n")
                    
                    f.write("# 开发工具\n")
                    for package in sorted(dev_packages):
                        f.write(f"{package}\n")
                
                print(f"✅ 开发依赖文件已生成: {self.dev_requirements_file}")
                print(f"   包含 {len(dev_packages)} 个开发工具")
            
            return {
                'production': production_packages,
                'development': dev_packages
            }
            
        except subprocess.CalledProcessError as e:
            print(f"❌ 生成依赖文件失败: {e}")
            return None
    
    def categorize_dependencies(self, packages):
        """按功能分类依赖包"""
        categories = {
            'Web框架': [],
            '数据科学': [],
            '机器学习': [],
            '深度学习': [],
            '数据库': [],
            '工具库': [],
            '其他': []
        }
        
        # 包分类规则
        category_rules = {
            'Web框架': ['django', 'flask', 'fastapi', 'tornado', 'pyramid'],
            '数据科学': ['pandas', 'numpy', 'scipy', 'matplotlib', 'seaborn', 'plotly'],
            '机器学习': ['scikit-learn', 'xgboost', 'lightgbm', 'catboost'],
            '深度学习': ['tensorflow', 'torch', 'keras', 'pytorch'],
            '数据库': ['sqlalchemy', 'pymongo', 'redis', 'psycopg2'],
            '工具库': ['requests', 'click', 'pydantic', 'python-dotenv']
        }
        
        for package in packages:
            package_name = package.split('==')[0].lower()
            categorized = False
            
            for category, keywords in category_rules.items():
                if any(keyword in package_name for keyword in keywords):
                    categories[category].append(package)
                    categorized = True
                    break
            
            if not categorized:
                categories['其他'].append(package)
        
        return categories
    
    def install_from_requirements(self, dev=False, upgrade=False):
        """从requirements文件安装依赖"""
        print("=== 安装项目依赖 ===")
        
        req_file = self.dev_requirements_file if dev else self.requirements_file
        
        if not req_file.exists():
            print(f"❌ 依赖文件不存在: {req_file}")
            return False
        
        try:
            cmd = ['pip', 'install', '-r', str(req_file)]
            if upgrade:
                cmd.append('--upgrade')
            
            print(f"📦 正在安装依赖: {req_file.name}")
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            print("✅ 依赖安装成功")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"❌ 依赖安装失败: {e}")
            print(f"错误输出: {e.stderr}")
            return False
    
    def check_outdated_packages(self):
        """检查过时的包"""
        print("\n=== 检查过时的包 ===")
        
        try:
            cmd = ['pip', 'list', '--outdated', '--format=json']
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            if result.stdout.strip():
                outdated_packages = json.loads(result.stdout)
                
                if outdated_packages:
                    print(f"\n📊 发现 {len(outdated_packages)} 个可更新的包:")
                    
                    # 创建DataFrame用于展示
                    df = pd.DataFrame(outdated_packages)
                    df = df.sort_values('name')
                    
                    for _, package in df.iterrows():
                        print(f"  • {package['name']}: {package['version']} → {package['latest_version']}")
                    
                    return outdated_packages
                else:
                    print("✅ 所有包都是最新版本")
                    return []
            else:
                print("✅ 所有包都是最新版本")
                return []
                
        except subprocess.CalledProcessError as e:
            print(f"❌ 检查更新失败: {e}")
            return None
        except json.JSONDecodeError as e:
            print(f"❌ 解析更新信息失败: {e}")
            return None
    
    def create_lock_file(self):
        """创建锁定文件"""
        print("\n=== 创建依赖锁定文件 ===")
        
        try:
            # 获取精确的包版本信息
            cmd = ['pip', 'freeze']
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            lock_content = {
                'generated_at': datetime.now().isoformat(),
                'python_version': f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
                'platform': sys.platform,
                'packages': {}
            }
            
            # 解析包信息
            for line in result.stdout.strip().split('\n'):
                if line.strip() and '==' in line:
                    name, version = line.split('==')
                    lock_content['packages'][name] = version
            
            # 保存锁定文件
            with open(self.lock_file, 'w', encoding='utf-8') as f:
                json.dump(lock_content, f, indent=2, ensure_ascii=False)
            
            print(f"✅ 锁定文件已创建: {self.lock_file}")
            print(f"   锁定了 {len(lock_content['packages'])} 个包的版本")
            
            return lock_content
            
        except subprocess.CalledProcessError as e:
            print(f"❌ 创建锁定文件失败: {e}")
            return None

# 创建依赖管理器实例
dep_manager = DependencyManager()

# 演示依赖管理功能
print("🔧 开始依赖包管理...")

# 生成requirements文件
dependencies = dep_manager.generate_requirements()

if dependencies:
    print(f"\n📊 依赖统计:")
    print(f"  生产环境: {len(dependencies['production'])} 个包")
    print(f"  开发环境: {len(dependencies['development'])} 个包")
    
    # 检查过时的包
    outdated = dep_manager.check_outdated_packages()
    
    # 创建锁定文件
    lock_info = dep_manager.create_lock_file()
```

### 依赖版本管理策略

```python
# 版本管理和冲突解决工具
import re
import requests
from packaging import version
import matplotlib.pyplot as plt
import networkx as nx
from collections import defaultdict

class VersionManager:
    """版本管理器"""
    
    def __init__(self):
        self.version_patterns = {
            'exact': r'^([a-zA-Z0-9_-]+)==([0-9.]+)$',
            'minimum': r'^([a-zA-Z0-9_-]+)>=([0-9.]+)$',
            'compatible': r'^([a-zA-Z0-9_-]+)~=([0-9.]+)$',
            'range': r'^([a-zA-Z0-9_-]+)>=([0-9.]+),<([0-9.]+)$'
        }
    
    def analyze_version_constraints(self, requirements_content):
        """分析版本约束"""
        print("=== 版本约束分析 ===")
        
        constraints = {
            'exact': [],      # 精确版本 ==
            'minimum': [],    # 最小版本 >=
            'compatible': [], # 兼容版本 ~=
            'range': [],      # 版本范围
            'unconstrained': [] # 无约束
        }
        
        lines = requirements_content.strip().split('\n')
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # 检查各种版本约束模式
            constraint_found = False
            
            for constraint_type, pattern in self.version_patterns.items():
                match = re.match(pattern, line)
                if match:
                    constraints[constraint_type].append({
                        'package': match.group(1),
                        'version': match.group(2),
                        'line': line
                    })
                    constraint_found = True
                    break
            
            if not constraint_found and '==' not in line and '>=' not in line:
                # 无版本约束的包
                package_name = line.split()[0] if line else ''
                if package_name:
                    constraints['unconstrained'].append({
                        'package': package_name,
                        'line': line
                    })
        
        # 输出分析结果
        total_packages = sum(len(packages) for packages in constraints.values())
        print(f"\n📊 版本约束统计 (共 {total_packages} 个包):")
        
        for constraint_type, packages in constraints.items():
            if packages:
                print(f"  • {constraint_type}: {len(packages)} 个包")
                for pkg in packages[:3]:  # 显示前3个示例
                    print(f"    - {pkg['line']}")
                if len(packages) > 3:
                    print(f"    ... 还有 {len(packages) - 3} 个")
        
        return constraints
    
    def suggest_version_strategy(self, package_name, current_version=None):
        """建议版本管理策略"""
        print(f"\n=== {package_name} 版本策略建议 ===")
        
        strategies = {
            '精确固定 (==)': {
                'pros': ['完全可重现', '避免意外更新', '部署一致性'],
                'cons': ['无法获得bug修复', '安全更新滞后', '维护成本高'],
                'use_case': '生产环境、关键系统',
                'example': f'{package_name}==1.2.3'
            },
            '兼容版本 (~=)': {
                'pros': ['自动获得补丁更新', '保持API兼容', '平衡稳定性'],
                'cons': ['可能引入小问题', '需要定期测试'],
                'use_case': '大多数项目的推荐选择',
                'example': f'{package_name}~=1.2.0'
            },
            '最小版本 (>=)': {
                'pros': ['灵活性最高', '自动获得所有更新', '功能最新'],
                'cons': ['可能破坏兼容性', '不可预测', '测试负担重'],
                'use_case': '开发环境、实验项目',
                'example': f'{package_name}>=1.2.0'
            },
            '版本范围': {
                'pros': ['精确控制更新范围', '平衡稳定性和更新'],
                'cons': ['配置复杂', '需要深入了解版本语义'],
                'use_case': '复杂项目、多环境部署',
                'example': f'{package_name}>=1.2.0,<2.0.0'
            }
        }
        
        for strategy, details in strategies.items():
            print(f"\n🔧 {strategy}:")
            print(f"   示例: {details['example']}")
            print(f"   适用: {details['use_case']}")
            print(f"   优点: {', '.join(details['pros'])}")
            print(f"   缺点: {', '.join(details['cons'])}")
        
        return strategies
    
    def detect_dependency_conflicts(self, requirements_file):
        """检测依赖冲突"""
        print("\n=== 依赖冲突检测 ===")
        
        try:
            # 使用pip-tools检查冲突
            cmd = ['pip-compile', '--dry-run', str(requirements_file)]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            conflicts = []
            
            if result.returncode != 0:
                # 解析错误信息中的冲突
                error_lines = result.stderr.split('\n')
                for line in error_lines:
                    if 'conflict' in line.lower() or 'incompatible' in line.lower():
                        conflicts.append(line.strip())
            
            if conflicts:
                print(f"⚠️ 发现 {len(conflicts)} 个潜在冲突:")
                for conflict in conflicts:
                    print(f"  • {conflict}")
            else:
                print("✅ 未发现明显的依赖冲突")
            
            return conflicts
            
        except FileNotFoundError:
            print("⚠️ pip-tools未安装，无法进行冲突检测")
            print("   安装命令: pip install pip-tools")
            return []
        except Exception as e:
            print(f"❌ 冲突检测失败: {e}")
            return []

# 创建版本管理器
version_manager = VersionManager()

# 示例requirements内容
sample_requirements = """
# Web框架
django==4.2.7
flask>=2.0.0
fastapi~=0.104.0

# 数据科学
pandas>=1.5.0,<3.0.0
numpy==1.24.3
matplotlib~=3.7.0

# 机器学习
scikit-learn
tensorflow>=2.13.0
torch==2.1.0
"""

# 分析版本约束
constraints = version_manager.analyze_version_constraints(sample_requirements)

# 提供版本策略建议
version_manager.suggest_version_strategy('pandas', '1.5.3')
```

## 4.2.3 常用AI开发包安装指南

### 核心AI开发包

```python
# AI开发包安装和配置指南
import subprocess
import sys
import importlib
from pathlib import Path
import matplotlib.pyplot as plt
import numpy as np

class AIPackageInstaller:
    """AI开发包安装器"""
    
    def __init__(self):
        self.ai_packages = {
            '数据科学基础': {
                'numpy': 'pip install numpy',
                'pandas': 'pip install pandas',
                'matplotlib': 'pip install matplotlib',
                'seaborn': 'pip install seaborn',
                'scipy': 'pip install scipy',
                'plotly': 'pip install plotly'
            },
            '机器学习': {
                'scikit-learn': 'pip install scikit-learn',
                'xgboost': 'pip install xgboost',
                'lightgbm': 'pip install lightgbm',
                'catboost': 'pip install catboost'
            },
            '深度学习': {
                'tensorflow': 'pip install tensorflow',
                'torch': 'pip install torch torchvision torchaudio',
                'keras': 'pip install keras',
                'transformers': 'pip install transformers'
            },
            '自然语言处理': {
                'nltk': 'pip install nltk',
                'spacy': 'pip install spacy',
                'gensim': 'pip install gensim',
                'textblob': 'pip install textblob'
            },
            '计算机视觉': {
                'opencv-python': 'pip install opencv-python',
                'pillow': 'pip install pillow',
                'imageio': 'pip install imageio',
                'albumentations': 'pip install albumentations'
            },
            '开发工具': {
                'jupyter': 'pip install jupyter',
                'notebook': 'pip install notebook',
                'ipython': 'pip install ipython',
                'tqdm': 'pip install tqdm'
            }
        }
    
    def check_package_installation(self, package_name):
        """检查包是否已安装"""
        try:
            importlib.import_module(package_name)
            return True
        except ImportError:
            return False
    
    def install_package_category(self, category):
        """安装指定类别的包"""
        if category not in self.ai_packages:
            print(f"❌ 未知类别: {category}")
            return False
        
        print(f"\n=== 安装 {category} 相关包 ===")
        
        packages = self.ai_packages[category]
        success_count = 0
        
        for package_name, install_cmd in packages.items():
            print(f"\n📦 安装 {package_name}...")
            
            # 检查是否已安装
            if self.check_package_installation(package_name.replace('-', '_')):
                print(f"✅ {package_name} 已安装")
                success_count += 1
                continue
            
            try:
                # 执行安装命令
                result = subprocess.run(
                    install_cmd.split(), 
                    capture_output=True, 
                    text=True, 
                    check=True
                )
                print(f"✅ {package_name} 安装成功")
                success_count += 1
                
            except subprocess.CalledProcessError as e:
                print(f"❌ {package_name} 安装失败: {e}")
                print(f"   错误信息: {e.stderr}")
        
        print(f"\n📊 安装结果: {success_count}/{len(packages)} 个包安装成功")
        return success_count == len(packages)
    
    def create_ai_environment_template(self):
        """创建AI开发环境模板"""
        print("\n=== 创建AI开发环境模板 ===")
        
        # 基础AI开发环境requirements
        ai_requirements = {
            'basic': [
                'numpy>=1.21.0',
                'pandas>=1.3.0',
                'matplotlib>=3.5.0',
                'seaborn>=0.11.0',
                'scipy>=1.7.0',
                'scikit-learn>=1.0.0',
                'jupyter>=1.0.0',
                'notebook>=6.4.0',
                'tqdm>=4.62.0'
            ],
            'ml_advanced': [
                'xgboost>=1.5.0',
                'lightgbm>=3.3.0',
                'catboost>=1.0.0',
                'optuna>=2.10.0',
                'shap>=0.40.0'
            ],
            'deep_learning': [
                'tensorflow>=2.8.0',
                'torch>=1.12.0',
                'torchvision>=0.13.0',
                'transformers>=4.20.0',
                'datasets>=2.0.0'
            ],
            'nlp': [
                'nltk>=3.7',
                'spacy>=3.4.0',
                'gensim>=4.2.0',
                'textblob>=0.17.0'
            ],
            'cv': [
                'opencv-python>=4.6.0',
                'pillow>=9.0.0',
                'imageio>=2.19.0',
                'albumentations>=1.2.0'
            ]
        }
        
        # 创建不同级别的requirements文件
        templates = {
            'requirements-basic.txt': ai_requirements['basic'],
            'requirements-ml.txt': ai_requirements['basic'] + ai_requirements['ml_advanced'],
            'requirements-dl.txt': ai_requirements['basic'] + ai_requirements['deep_learning'],
            'requirements-nlp.txt': ai_requirements['basic'] + ai_requirements['nlp'],
            'requirements-cv.txt': ai_requirements['basic'] + ai_requirements['cv'],
            'requirements-full.txt': (
                ai_requirements['basic'] + 
                ai_requirements['ml_advanced'] + 
                ai_requirements['deep_learning'] + 
                ai_requirements['nlp'] + 
                ai_requirements['cv']
            )
        }
        
        for filename, packages in templates.items():
            filepath = Path(filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(f"# AI开发环境 - {filename.replace('requirements-', '').replace('.txt', '')}\n")
                f.write(f"# 生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                for package in sorted(set(packages)):
                    f.write(f"{package}\n")
            
            print(f"✅ 模板已创建: {filepath} ({len(set(packages))} 个包)")
        
        return templates
    
    def visualize_package_ecosystem(self):
        """可视化AI包生态系统"""
        print("\n=== AI包生态系统可视化 ===")
        
        # 创建包依赖关系图
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('AI开发包生态系统分析', fontsize=16, fontweight='bold')
        
        # 1. 包类别分布
        categories = list(self.ai_packages.keys())
        package_counts = [len(packages) for packages in self.ai_packages.values()]
        colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD']
        
        ax1.pie(package_counts, labels=categories, colors=colors, autopct='%1.1f%%',
                startangle=90)
        ax1.set_title('AI包类别分布', fontsize=12, fontweight='bold')
        
        # 2. 安装复杂度评估
        complexity_scores = {
            '数据科学基础': 2,
            '机器学习': 4,
            '深度学习': 8,
            '自然语言处理': 6,
            '计算机视觉': 7,
            '开发工具': 3
        }
        
        importance_scores = {
            '数据科学基础': 10,
            '机器学习': 9,
            '深度学习': 8,
            '自然语言处理': 7,
            '计算机视觉': 7,
            '开发工具': 8
        }
        
        x_complexity = [complexity_scores[cat] for cat in categories]
        y_importance = [importance_scores[cat] for cat in categories]
        sizes = [count * 20 for count in package_counts]
        
        scatter = ax2.scatter(x_complexity, y_importance, s=sizes, 
                             c=colors, alpha=0.6, edgecolors='black')
        
        for i, cat in enumerate(categories):
            ax2.annotate(cat.replace('自然语言处理', 'NLP').replace('计算机视觉', 'CV'), 
                        (x_complexity[i], y_importance[i]), 
                        xytext=(5, 5), textcoords='offset points', 
                        fontsize=9, fontweight='bold')
        
        ax2.set_xlabel('安装复杂度', fontsize=11)
        ax2.set_ylabel('重要性评分', fontsize=11)
        ax2.set_title('包类别重要性vs复杂度', fontsize=12, fontweight='bold')
        ax2.grid(True, alpha=0.3)
        
        # 3. 学习路径推荐
        learning_path = {
            '第1阶段\n基础工具': ['numpy', 'pandas', 'matplotlib'],
            '第2阶段\n机器学习': ['scikit-learn', 'jupyter'],
            '第3阶段\n深度学习': ['tensorflow', 'torch'],
            '第4阶段\n专业领域': ['transformers', 'opencv-python']
        }
        
        stages = list(learning_path.keys())
        stage_counts = [len(packages) for packages in learning_path.values()]
        
        bars = ax3.bar(range(len(stages)), stage_counts, 
                      color=['#96CEB4', '#45B7D1', '#FF6B6B', '#FFEAA7'], alpha=0.8)
        
        ax3.set_xlabel('学习阶段', fontsize=11)
        ax3.set_ylabel('推荐包数量', fontsize=11)
        ax3.set_title('AI学习路径规划', fontsize=12, fontweight='bold')
        ax3.set_xticks(range(len(stages)))
        ax3.set_xticklabels(stages, rotation=45, ha='right')
        
        # 添加包名标签
        for bar, packages in zip(bars, learning_path.values()):
            height = bar.get_height()
            package_names = ', '.join(packages)
            ax3.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                     package_names, ha='center', va='bottom', 
                     fontsize=8, rotation=0)
        
        # 4. 环境配置建议
        env_types = ['轻量级', '标准版', '完整版', '专业版']
        package_nums = [10, 25, 45, 60]
        disk_space = [500, 2000, 8000, 15000]  # MB
        
        ax4_twin = ax4.twinx()
        
        bars1 = ax4.bar([x - 0.2 for x in range(len(env_types))], package_nums, 
                       width=0.4, label='包数量', color='#4ECDC4', alpha=0.8)
        bars2 = ax4_twin.bar([x + 0.2 for x in range(len(env_types))], disk_space, 
                            width=0.4, label='磁盘空间(MB)', color='#FF6B6B', alpha=0.8)
        
        ax4.set_xlabel('环境类型', fontsize=11)
        ax4.set_ylabel('包数量', fontsize=11, color='#4ECDC4')
        ax4_twin.set_ylabel('磁盘空间 (MB)', fontsize=11, color='#FF6B6B')
        ax4.set_title('环境配置方案对比', fontsize=12, fontweight='bold')
        ax4.set_xticks(range(len(env_types)))
        ax4.set_xticklabels(env_types)
        
        # 添加图例
        lines1, labels1 = ax4.get_legend_handles_labels()
        lines2, labels2 = ax4_twin.get_legend_handles_labels()
        ax4.legend(lines1 + lines2, labels1 + labels2, loc='upper left')
        
        plt.tight_layout()
        plt.show()

# 创建AI包安装器
ai_installer = AIPackageInstaller()

# 创建环境模板
templates = ai_installer.create_ai_environment_template()

# 可视化包生态系统
ai_installer.visualize_package_ecosystem()

print("\n🎯 AI开发环境配置建议:")
print("\n🔰 初学者 (轻量级):")
print("  pip install -r requirements-basic.txt")
print("\n📈 进阶者 (标准版):")
print("  pip install -r requirements-ml.txt")
print("\n🚀 专业者 (完整版):")
print("  pip install -r requirements-full.txt")
```

## 4.2.4 环境配置最佳实践

### 配置文件管理

```python
# 环境配置管理工具
import os
import json
import yaml
from pathlib import Path
from datetime import datetime

class EnvironmentConfigManager:
    """环境配置管理器"""
    
    def __init__(self, project_root=None):
        self.project_root = Path(project_root) if project_root else Path.cwd()
        self.config_dir = self.project_root / '.config'
        self.config_dir.mkdir(exist_ok=True)
        
    def create_environment_config(self):
        """创建环境配置文件"""
        print("=== 创建环境配置文件 ===")
        
        # 1. .env 文件 (环境变量)
        env_content = """
# 项目环境变量配置
# 开发环境设置
DEBUG=True
ENVIRONMENT=development

# 数据库配置
DATABASE_URL=sqlite:///./data/app.db
REDIS_URL=redis://localhost:6379/0

# API配置
API_KEY=your_api_key_here
SECRET_KEY=your_secret_key_here

# 模型配置
MODEL_PATH=./models
DATA_PATH=./data
LOG_LEVEL=INFO

# GPU配置
CUDA_VISIBLE_DEVICES=0
TF_FORCE_GPU_ALLOW_GROWTH=true
"""
        
        env_file = self.project_root / '.env'
        with open(env_file, 'w', encoding='utf-8') as f:
            f.write(env_content.strip())
        print(f"✅ 环境变量文件已创建: {env_file}")
        
        # 2. pyproject.toml (项目配置)
        pyproject_content = """
[build-system]
requires = ["setuptools>=45", "wheel", "setuptools_scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

[project]
name = "ai-project"
version = "0.1.0"
description = "AI项目模板"
authors = [{name = "Your Name", email = "your.email@example.com"}]
requires-python = ">=3.8"
dependencies = [
    "numpy>=1.21.0",
    "pandas>=1.3.0",
    "scikit-learn>=1.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=6.0",
    "black>=22.0",
    "flake8>=4.0",
    "mypy>=0.950",
]

[tool.black]
line-length = 88
target-version = ['py38']

[tool.isort]
profile = "black"

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
"""
        
        pyproject_file = self.project_root / 'pyproject.toml'
        with open(pyproject_file, 'w', encoding='utf-8') as f:
            f.write(pyproject_content.strip())
        print(f"✅ 项目配置文件已创建: {pyproject_file}")
        
        # 3. setup.cfg (工具配置)
        setup_cfg_content = """
[metadata]
name = ai-project
version = 0.1.0
description = AI项目模板
long_description = file: README.md
long_description_content_type = text/markdown

[options]
packages = find:
python_requires = >=3.8
install_requires =
    numpy>=1.21.0
    pandas>=1.3.0
    scikit-learn>=1.0.0

[options.extras_require]
dev =
    pytest>=6.0
    black>=22.0
    flake8>=4.0
    mypy>=0.950

[flake8]
max-line-length = 88
extend-ignore = E203, W503
exclude = .git,__pycache__,build,dist

[mypy]
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
"""
        
        setup_cfg_file = self.project_root / 'setup.cfg'
        with open(setup_cfg_file, 'w', encoding='utf-8') as f:
            f.write(setup_cfg_content.strip())
        print(f"✅ 工具配置文件已创建: {setup_cfg_file}")
        
        # 4. .gitignore
        gitignore_content = """
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
.venv/
venv/
ENV/
env/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Project specific
.env
*.log
data/
models/
checkpoints/
*.pkl
*.joblib

# Jupyter
.ipynb_checkpoints/

# ML/AI
*.h5
*.pb
*.onnx
wandb/
mlruns/
"""
        
        gitignore_file = self.project_root / '.gitignore'
        with open(gitignore_file, 'w', encoding='utf-8') as f:
            f.write(gitignore_content.strip())
        print(f"✅ Git忽略文件已创建: {gitignore_file}")
        
        return {
            'env': env_file,
            'pyproject': pyproject_file,
            'setup_cfg': setup_cfg_file,
            'gitignore': gitignore_file
        }
    
    def create_development_scripts(self):
        """创建开发脚本"""
        print("\n=== 创建开发脚本 ===")
        
        scripts_dir = self.project_root / 'scripts'
        scripts_dir.mkdir(exist_ok=True)
        
        # 1. 环境设置脚本
        setup_script = """
#!/bin/bash
# 开发环境设置脚本

echo "🚀 设置AI开发环境..."

# 创建虚拟环境
if [ ! -d ".venv" ]; then
    echo "📦 创建虚拟环境..."
    python -m venv .venv
fi

# 激活虚拟环境
echo "🔧 激活虚拟环境..."
source .venv/bin/activate

# 升级pip
echo "⬆️ 升级pip..."
pip install --upgrade pip

# 安装依赖
echo "📚 安装项目依赖..."
if [ -f "requirements.txt" ]; then
    pip install -r requirements.txt
fi

if [ -f "requirements-dev.txt" ]; then
    pip install -r requirements-dev.txt
fi

# 安装项目本身
echo "🔨 安装项目..."
pip install -e .

echo "✅ 环境设置完成！"
echo "💡 使用 'source .venv/bin/activate' 激活环境"
"""
        
        setup_file = scripts_dir / 'setup_env.sh'
        with open(setup_file, 'w', encoding='utf-8') as f:
            f.write(setup_script.strip())
        setup_file.chmod(0o755)  # 添加执行权限
        print(f"✅ 环境设置脚本已创建: {setup_file}")
        
        # 2. 代码质量检查脚本
        quality_script = """
#!/bin/bash
# 代码质量检查脚本

echo "🔍 运行代码质量检查..."

# 代码格式化
echo "🎨 格式化代码..."
black .
isort .

# 代码检查
echo "🔎 运行flake8检查..."
flake8 .

# 类型检查
echo "🔬 运行mypy类型检查..."
mypy .

# 运行测试
echo "🧪 运行测试..."
pytest tests/ -v --cov=.

echo "✅ 代码质量检查完成！"
"""
        
        quality_file = scripts_dir / 'check_quality.sh'
        with open(quality_file, 'w', encoding='utf-8') as f:
            f.write(quality_script.strip())
        quality_file.chmod(0o755)
        print(f"✅ 质量检查脚本已创建: {quality_file}")
        
        return {
            'setup': setup_file,
            'quality': quality_file
        }

# 创建配置管理器
config_manager = EnvironmentConfigManager()

# 创建配置文件
config_files = config_manager.create_environment_config()

# 创建开发脚本
scripts = config_manager.create_development_scripts()

print("\n🎉 环境配置文件创建完成！")
print("\n📁 创建的文件:")
for file_type, filepath in config_files.items():
    print(f"  • {file_type}: {filepath.name}")

for script_type, filepath in scripts.items():
    print(f"  • {script_type} script: {filepath}")
```

## 本节总结

通过本节学习，我们掌握了Python环境和依赖管理的核心技能：

### 🎯 核心成果

1. **虚拟环境管理** - 学会创建、配置和管理Python虚拟环境
2. **依赖包管理** - 掌握requirements.txt的生成和维护
3. **版本控制策略** - 了解不同版本约束的使用场景
4. **AI包生态** - 熟悉常用AI开发包的安装和配置
5. **配置文件管理** - 建立标准化的项目配置体系

### 📊 环境管理检查清单

```python
# 环境管理完成度检查
def create_env_management_checklist():
    """创建环境管理检查清单"""
    
    checklist = {
        '虚拟环境': {
            '创建虚拟环境': True,
            '激活环境': True,
            '升级pip': True,
            '环境隔离': True
        },
        '依赖管理': {
            'requirements.txt': True,
            '版本固定': True,
            '依赖分类': True,
            '冲突检测': False
        },
        '配置文件': {
            '.env文件': True,
            'pyproject.toml': True,
            '.gitignore': True,
            '开发脚本': True
        },
        'AI包安装': {
            '基础包': True,
            '机器学习包': True,
            '深度学习包': False,
            '专业包': False
        }
    }
    
    print("=== Python环境管理检查清单 ===")
    
    total_items = 0
    completed_items = 0
    
    for category, items in checklist.items():
        print(f"\n📂 {category}:")
        for item, status in items.items():
            status_icon = "✅" if status else "⏳"
            print(f"  {status_icon} {item}")
            total_items += 1
            if status:
                completed_items += 1
    
    completion_rate = (completed_items / total_items) * 100
    print(f"\n📊 完成度: {completed_items}/{total_items} ({completion_rate:.1f}%)")
    
    return checklist

# 执行检查
checklist_result = create_env_management_checklist()

print("\n🚀 下一步行动:")
print("1. 完善依赖冲突检测机制")
print("2. 安装深度学习相关包")
print("3. 配置GPU环境 (如需要)")
print("4. 开始第一个AI项目开发")
```

### 💡 最佳实践总结

- **环境隔离**: 每个项目使用独立的虚拟环境
- **版本管理**: 使用合适的版本约束策略
- **依赖分类**: 区分生产和开发依赖
- **配置标准化**: 使用标准配置文件管理项目
- **自动化脚本**: 创建环境设置和质量检查脚本

现在你已经具备了完善的Python环境管理能力，可以为任何AI项目创建稳定、可重现的开发环境。在下一节中，我们将学习如何准备和管理AI项目所需的数据集！
```