# 1.4.4 å·ç§¯ç¥ç»ç½‘ç»œ (CNN)

## 1. CNNæ¦‚è¿°ä¸æ ¸å¿ƒæ¦‚å¿µ

### 1.1 ä»€ä¹ˆæ˜¯å·ç§¯ç¥ç»ç½‘ç»œ

å·ç§¯ç¥ç»ç½‘ç»œï¼ˆConvolutional Neural Network, CNNï¼‰æ˜¯ä¸€ç§ä¸“é—¨ç”¨äºå¤„ç†å…·æœ‰ç½‘æ ¼ç»“æ„æ•°æ®çš„æ·±åº¦å­¦ä¹ æ¨¡å‹ï¼Œç‰¹åˆ«é€‚ç”¨äºå›¾åƒå¤„ç†ã€è®¡ç®—æœºè§†è§‰ç­‰ä»»åŠ¡ã€‚

```mermaid
graph LR
    subgraph "CNNæ¶æ„"
        A[è¾“å…¥å›¾åƒ] --> B[å·ç§¯å±‚]
        B --> C[æ¿€æ´»å‡½æ•°]
        C --> D[æ± åŒ–å±‚]
        D --> E[å·ç§¯å±‚]
        E --> F[æ¿€æ´»å‡½æ•°]
        F --> G[æ± åŒ–å±‚]
        G --> H[å±•å¹³å±‚]
        H --> I[å…¨è¿æ¥å±‚]
        I --> J[è¾“å‡º]
    end
    
    subgraph "ç‰¹å¾æå–"
        K[ä½çº§ç‰¹å¾] --> L[è¾¹ç¼˜ã€è§’ç‚¹]
        L --> M[ä¸­çº§ç‰¹å¾]
        M --> N[çº¹ç†ã€å½¢çŠ¶]
        N --> O[é«˜çº§ç‰¹å¾]
        O --> P[å¯¹è±¡ã€è¯­ä¹‰]
    end
```

**CNNçš„æ ¸å¿ƒä¼˜åŠ¿ï¼š**
- **å±€éƒ¨è¿æ¥**: æ¯ä¸ªç¥ç»å…ƒåªä¸å±€éƒ¨åŒºåŸŸè¿æ¥
- **æƒé‡å…±äº«**: åŒä¸€ä¸ªå·ç§¯æ ¸åœ¨æ•´ä¸ªè¾“å…¥ä¸Šå…±äº«å‚æ•°
- **å¹³ç§»ä¸å˜æ€§**: å¯¹è¾“å…¥çš„å¹³ç§»å…·æœ‰ä¸€å®šçš„ä¸å˜æ€§
- **å±‚æ¬¡ç‰¹å¾å­¦ä¹ **: ä»ä½çº§åˆ°é«˜çº§ç‰¹å¾çš„é€å±‚æŠ½è±¡

```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import seaborn as sns
from scipy import ndimage
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
import warnings
warnings.filterwarnings('ignore')

class ConvolutionDemo:
    """å·ç§¯æ“ä½œæ¼”ç¤ºç±»"""
    
    def __init__(self):
        pass
    
    def create_sample_image(self):
        """åˆ›å»ºç¤ºä¾‹å›¾åƒ"""
        # åˆ›å»ºä¸€ä¸ªç®€å•çš„å›¾åƒ
        image = np.zeros((8, 8))
        
        # æ·»åŠ ä¸€äº›ç‰¹å¾
        image[1:3, 1:7] = 1  # æ°´å¹³çº¿
        image[1:7, 1:3] = 1  # å‚ç›´çº¿
        image[5:7, 5:7] = 1  # å°æ–¹å—
        
        return image
    
    def convolution_2d(self, image, kernel, stride=1, padding=0):
        """2Då·ç§¯æ“ä½œ"""
        # æ·»åŠ padding
        if padding > 0:
            image = np.pad(image, padding, mode='constant', constant_values=0)
        
        # è®¡ç®—è¾“å‡ºå°ºå¯¸
        output_height = (image.shape[0] - kernel.shape[0]) // stride + 1
        output_width = (image.shape[1] - kernel.shape[1]) // stride + 1
        
        # åˆå§‹åŒ–è¾“å‡º
        output = np.zeros((output_height, output_width))
        
        # æ‰§è¡Œå·ç§¯
        for i in range(0, output_height * stride, stride):
            for j in range(0, output_width * stride, stride):
                # æå–æ„Ÿå—é‡
                receptive_field = image[i:i+kernel.shape[0], j:j+kernel.shape[1]]
                # è®¡ç®—å·ç§¯
                output[i//stride, j//stride] = np.sum(receptive_field * kernel)
        
        return output
    
    def demonstrate_convolution_process(self):
        """æ¼”ç¤ºå·ç§¯è¿‡ç¨‹"""
        print(f"\n{'='*80}")
        print(f"ğŸ” å·ç§¯æ“ä½œè¯¦ç»†æ¼”ç¤º")
        print(f"{'='*80}")
        
        # åˆ›å»ºç¤ºä¾‹å›¾åƒå’Œå·ç§¯æ ¸
        image = self.create_sample_image()
        
        # å®šä¹‰ä¸åŒçš„å·ç§¯æ ¸
        kernels = {
            'è¾¹ç¼˜æ£€æµ‹ (å‚ç›´)': np.array([[-1, 0, 1],
                                      [-1, 0, 1],
                                      [-1, 0, 1]]),
            'è¾¹ç¼˜æ£€æµ‹ (æ°´å¹³)': np.array([[-1, -1, -1],
                                      [ 0,  0,  0],
                                      [ 1,  1,  1]]),
            'æ¨¡ç³Š': np.array([[1, 1, 1],
                            [1, 1, 1],
                            [1, 1, 1]]) / 9,
            'é”åŒ–': np.array([[ 0, -1,  0],
                            [-1,  5, -1],
                            [ 0, -1,  0]])
        }
        
        fig, axes = plt.subplots(2, len(kernels) + 1, figsize=(20, 10))
        
        # æ˜¾ç¤ºåŸå§‹å›¾åƒ
        axes[0, 0].imshow(image, cmap='gray')
        axes[0, 0].set_title('åŸå§‹å›¾åƒ', fontweight='bold')
        axes[0, 0].axis('off')
        
        # æ˜¾ç¤ºå›¾åƒæ•°å€¼
        axes[1, 0].imshow(image, cmap='gray')
        for i in range(image.shape[0]):
            for j in range(image.shape[1]):
                axes[1, 0].text(j, i, f'{image[i,j]:.0f}', 
                               ha='center', va='center', color='red', fontweight='bold')
        axes[1, 0].set_title('åŸå§‹å›¾åƒ (æ•°å€¼)', fontweight='bold')
        axes[1, 0].axis('off')
        
        # å¯¹æ¯ä¸ªå·ç§¯æ ¸è¿›è¡Œå·ç§¯
        for idx, (kernel_name, kernel) in enumerate(kernels.items()):
            # æ‰§è¡Œå·ç§¯
            conv_result = self.convolution_2d(image, kernel)
            
            # æ˜¾ç¤ºå·ç§¯ç»“æœ
            axes[0, idx + 1].imshow(conv_result, cmap='gray')
            axes[0, idx + 1].set_title(f'{kernel_name}\nå·ç§¯ç»“æœ', fontweight='bold')
            axes[0, idx + 1].axis('off')
            
            # æ˜¾ç¤ºå·ç§¯æ ¸
            im = axes[1, idx + 1].imshow(kernel, cmap='RdBu', vmin=-1, vmax=1)
            for i in range(kernel.shape[0]):
                for j in range(kernel.shape[1]):
                    axes[1, idx + 1].text(j, i, f'{kernel[i,j]:.1f}', 
                                         ha='center', va='center', 
                                         color='white' if abs(kernel[i,j]) > 0.5 else 'black',
                                         fontweight='bold')
            axes[1, idx + 1].set_title(f'{kernel_name}\nå·ç§¯æ ¸', fontweight='bold')
            axes[1, idx + 1].axis('off')
            plt.colorbar(im, ax=axes[1, idx + 1], fraction=0.046, pad=0.04)
        
        plt.tight_layout()
        plt.show()
        
        # è¯¦ç»†è§£é‡Šå·ç§¯è¿‡ç¨‹
        print(f"\nğŸ” å·ç§¯è®¡ç®—è¯¦è§£:")
        kernel = kernels['è¾¹ç¼˜æ£€æµ‹ (å‚ç›´)']
        print(f"\nä½¿ç”¨å‚ç›´è¾¹ç¼˜æ£€æµ‹å·ç§¯æ ¸:")
        print(kernel)
        
        # æ‰‹åŠ¨è®¡ç®—ç¬¬ä¸€ä¸ªä½ç½®çš„å·ç§¯
        receptive_field = image[0:3, 0:3]
        conv_value = np.sum(receptive_field * kernel)
        
        print(f"\nç¬¬ä¸€ä¸ªä½ç½®çš„è®¡ç®—:")
        print(f"æ„Ÿå—é‡:")
        print(receptive_field)
        print(f"é€å…ƒç´ ç›¸ä¹˜åæ±‚å’Œ: {conv_value:.2f}")
        
        return image, kernels
    
    def visualize_receptive_field(self):
        """å¯è§†åŒ–æ„Ÿå—é‡"""
        print(f"\n{'='*80}")
        print(f"ğŸ‘ï¸ æ„Ÿå—é‡å¯è§†åŒ–")
        print(f"{'='*80}")
        
        # åˆ›å»ºä¸€ä¸ªè¾ƒå¤§çš„å›¾åƒ
        image = np.random.rand(10, 10)
        kernel_size = 3
        
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        
        # æ˜¾ç¤ºä¸åŒä½ç½®çš„æ„Ÿå—é‡
        positions = [(1, 1), (3, 3), (6, 6)]
        
        for idx, (row, col) in enumerate(positions):
            # åŸå§‹å›¾åƒ
            axes[0, idx].imshow(image, cmap='viridis', alpha=0.7)
            
            # é«˜äº®æ„Ÿå—é‡
            rect = Rectangle((col-0.5, row-0.5), kernel_size, kernel_size, 
                           linewidth=3, edgecolor='red', facecolor='none')
            axes[0, idx].add_patch(rect)
            
            # æ ‡è®°ä¸­å¿ƒç‚¹
            axes[0, idx].plot(col+1, row+1, 'ro', markersize=10)
            
            axes[0, idx].set_title(f'æ„Ÿå—é‡ä½ç½® ({row+1}, {col+1})', fontweight='bold')
            axes[0, idx].set_xlim(-0.5, 9.5)
            axes[0, idx].set_ylim(9.5, -0.5)
            
            # æå–å¹¶æ˜¾ç¤ºæ„Ÿå—é‡
            receptive_field = image[row:row+kernel_size, col:col+kernel_size]
            im = axes[1, idx].imshow(receptive_field, cmap='viridis')
            
            # æ·»åŠ æ•°å€¼æ ‡æ³¨
            for i in range(kernel_size):
                for j in range(kernel_size):
                    axes[1, idx].text(j, i, f'{receptive_field[i,j]:.2f}', 
                                     ha='center', va='center', color='white', fontweight='bold')
            
            axes[1, idx].set_title(f'æ„Ÿå—é‡å†…å®¹', fontweight='bold')
            plt.colorbar(im, ax=axes[1, idx], fraction=0.046, pad=0.04)
        
        plt.tight_layout()
        plt.show()
        
        return image
    
    def demonstrate_stride_padding(self):
        """æ¼”ç¤ºæ­¥é•¿å’Œå¡«å……çš„å½±å“"""
        print(f"\n{'='*80}")
        print(f"ğŸ“ æ­¥é•¿å’Œå¡«å……æ¼”ç¤º")
        print(f"{'='*80}")
        
        # åˆ›å»ºç¤ºä¾‹å›¾åƒ
        image = np.ones((6, 6))
        image[2:4, 2:4] = 0  # ä¸­å¿ƒé»‘è‰²æ–¹å—
        
        kernel = np.array([[1, 0, -1],
                          [1, 0, -1],
                          [1, 0, -1]])  # å‚ç›´è¾¹ç¼˜æ£€æµ‹
        
        # ä¸åŒçš„æ­¥é•¿å’Œå¡«å……ç»„åˆ
        configs = [
            {'stride': 1, 'padding': 0, 'name': 'stride=1, padding=0'},
            {'stride': 2, 'padding': 0, 'name': 'stride=2, padding=0'},
            {'stride': 1, 'padding': 1, 'name': 'stride=1, padding=1'},
            {'stride': 2, 'padding': 1, 'name': 'stride=2, padding=1'}
        ]
        
        fig, axes = plt.subplots(2, len(configs), figsize=(20, 10))
        
        for idx, config in enumerate(configs):
            # æ‰§è¡Œå·ç§¯
            result = self.convolution_2d(image, kernel, 
                                       stride=config['stride'], 
                                       padding=config['padding'])
            
            # æ˜¾ç¤ºè¾“å…¥ï¼ˆå¯èƒ½æœ‰paddingï¼‰
            if config['padding'] > 0:
                padded_image = np.pad(image, config['padding'], 
                                    mode='constant', constant_values=0)
            else:
                padded_image = image
            
            axes[0, idx].imshow(padded_image, cmap='gray')
            axes[0, idx].set_title(f'è¾“å…¥å›¾åƒ\n{config["name"]}\nå°ºå¯¸: {padded_image.shape}', 
                                 fontweight='bold')
            axes[0, idx].axis('off')
            
            # æ˜¾ç¤ºè¾“å‡º
            axes[1, idx].imshow(result, cmap='gray')
            axes[1, idx].set_title(f'å·ç§¯è¾“å‡º\nå°ºå¯¸: {result.shape}', fontweight='bold')
            axes[1, idx].axis('off')
            
            # æ·»åŠ ç½‘æ ¼æ˜¾ç¤ºæ­¥é•¿
            if config['stride'] > 1:
                for i in range(0, padded_image.shape[0], config['stride']):
                    axes[0, idx].axhline(i-0.5, color='red', linewidth=2, alpha=0.7)
                for j in range(0, padded_image.shape[1], config['stride']):
                    axes[0, idx].axvline(j-0.5, color='red', linewidth=2, alpha=0.7)
        
        plt.tight_layout()
        plt.show()
        
        # è®¡ç®—è¾“å‡ºå°ºå¯¸å…¬å¼
        print(f"\nğŸ“ è¾“å‡ºå°ºå¯¸è®¡ç®—å…¬å¼:")
        print(f"   è¾“å‡ºé«˜åº¦ = (è¾“å…¥é«˜åº¦ + 2Ã—å¡«å…… - å·ç§¯æ ¸é«˜åº¦) Ã· æ­¥é•¿ + 1")
        print(f"   è¾“å‡ºå®½åº¦ = (è¾“å…¥å®½åº¦ + 2Ã—å¡«å…… - å·ç§¯æ ¸å®½åº¦) Ã· æ­¥é•¿ + 1")
        
        print(f"\nğŸ“Š å„é…ç½®çš„è¾“å‡ºå°ºå¯¸:")
        for config in configs:
            h_out = (6 + 2*config['padding'] - 3) // config['stride'] + 1
            w_out = (6 + 2*config['padding'] - 3) // config['stride'] + 1
            print(f"   {config['name']}: ({h_out}, {w_out})")
        
        return configs

# å·ç§¯æ“ä½œæ¼”ç¤º
print("\n" + "=" * 80)
print("ğŸ§  å·ç§¯ç¥ç»ç½‘ç»œ - å·ç§¯æ“ä½œè¯¦è§£")
print("=" * 80)

conv_demo = ConvolutionDemo()

# æ¼”ç¤ºå·ç§¯è¿‡ç¨‹
image, kernels = conv_demo.demonstrate_convolution_process()

# å¯è§†åŒ–æ„Ÿå—é‡
receptive_field_image = conv_demo.visualize_receptive_field()

# æ¼”ç¤ºæ­¥é•¿å’Œå¡«å……
stride_padding_configs = conv_demo.demonstrate_stride_padding()
```

## 2. æ± åŒ–æ“ä½œ

### 2.1 æ± åŒ–çš„ä½œç”¨

æ± åŒ–ï¼ˆPoolingï¼‰æ˜¯CNNä¸­çš„ä¸‹é‡‡æ ·æ“ä½œï¼Œç”¨äºå‡å°‘ç‰¹å¾å›¾çš„ç©ºé—´å°ºå¯¸ï¼Œé™ä½è®¡ç®—å¤æ‚åº¦ï¼Œå¹¶æä¾›ä¸€å®šçš„å¹³ç§»ä¸å˜æ€§ã€‚

```python
class PoolingDemo:
    """æ± åŒ–æ“ä½œæ¼”ç¤ºç±»"""
    
    def __init__(self):
        pass
    
    def max_pooling(self, feature_map, pool_size=2, stride=2):
        """æœ€å¤§æ± åŒ–"""
        output_height = (feature_map.shape[0] - pool_size) // stride + 1
        output_width = (feature_map.shape[1] - pool_size) // stride + 1
        
        output = np.zeros((output_height, output_width))
        
        for i in range(0, output_height * stride, stride):
            for j in range(0, output_width * stride, stride):
                pool_region = feature_map[i:i+pool_size, j:j+pool_size]
                output[i//stride, j//stride] = np.max(pool_region)
        
        return output
    
    def average_pooling(self, feature_map, pool_size=2, stride=2):
        """å¹³å‡æ± åŒ–"""
        output_height = (feature_map.shape[0] - pool_size) // stride + 1
        output_width = (feature_map.shape[1] - pool_size) // stride + 1
        
        output = np.zeros((output_height, output_width))
        
        for i in range(0, output_height * stride, stride):
            for j in range(0, output_width * stride, stride):
                pool_region = feature_map[i:i+pool_size, j:j+pool_size]
                output[i//stride, j//stride] = np.mean(pool_region)
        
        return output
    
    def global_average_pooling(self, feature_map):
        """å…¨å±€å¹³å‡æ± åŒ–"""
        return np.mean(feature_map)
    
    def demonstrate_pooling_operations(self):
        """æ¼”ç¤ºä¸åŒæ± åŒ–æ“ä½œ"""
        print(f"\n{'='*80}")
        print(f"ğŸŠ æ± åŒ–æ“ä½œè¯¦ç»†æ¼”ç¤º")
        print(f"{'='*80}")
        
        # åˆ›å»ºç¤ºä¾‹ç‰¹å¾å›¾
        np.random.seed(42)
        feature_map = np.random.rand(8, 8) * 10
        feature_map = feature_map.astype(int)  # è½¬æ¢ä¸ºæ•´æ•°ä¾¿äºè§‚å¯Ÿ
        
        # ä¸åŒçš„æ± åŒ–æ“ä½œ
        max_pooled = self.max_pooling(feature_map, pool_size=2, stride=2)
        avg_pooled = self.average_pooling(feature_map, pool_size=2, stride=2)
        global_avg = self.global_average_pooling(feature_map)
        
        fig, axes = plt.subplots(2, 3, figsize=(18, 12))
        
        # åŸå§‹ç‰¹å¾å›¾
        im1 = axes[0, 0].imshow(feature_map, cmap='viridis')
        axes[0, 0].set_title('åŸå§‹ç‰¹å¾å›¾\n(8Ã—8)', fontweight='bold')
        
        # æ·»åŠ æ•°å€¼æ ‡æ³¨
        for i in range(feature_map.shape[0]):
            for j in range(feature_map.shape[1]):
                axes[0, 0].text(j, i, f'{feature_map[i,j]}', 
                               ha='center', va='center', color='white', fontweight='bold')
        
        # æ·»åŠ æ± åŒ–åŒºåŸŸç½‘æ ¼
        for i in range(0, 8, 2):
            axes[0, 0].axhline(i-0.5, color='red', linewidth=2)
        for j in range(0, 8, 2):
            axes[0, 0].axvline(j-0.5, color='red', linewidth=2)
        
        plt.colorbar(im1, ax=axes[0, 0], fraction=0.046, pad=0.04)
        
        # æœ€å¤§æ± åŒ–ç»“æœ
        im2 = axes[0, 1].imshow(max_pooled, cmap='viridis')
        axes[0, 1].set_title('æœ€å¤§æ± åŒ–\n(4Ã—4)', fontweight='bold')
        
        for i in range(max_pooled.shape[0]):
            for j in range(max_pooled.shape[1]):
                axes[0, 1].text(j, i, f'{max_pooled[i,j]:.0f}', 
                               ha='center', va='center', color='white', fontweight='bold')
        
        plt.colorbar(im2, ax=axes[0, 1], fraction=0.046, pad=0.04)
        
        # å¹³å‡æ± åŒ–ç»“æœ
        im3 = axes[0, 2].imshow(avg_pooled, cmap='viridis')
        axes[0, 2].set_title('å¹³å‡æ± åŒ–\n(4Ã—4)', fontweight='bold')
        
        for i in range(avg_pooled.shape[0]):
            for j in range(avg_pooled.shape[1]):
                axes[0, 2].text(j, i, f'{avg_pooled[i,j]:.1f}', 
                               ha='center', va='center', color='white', fontweight='bold')
        
        plt.colorbar(im3, ax=axes[0, 2], fraction=0.046, pad=0.04)
        
        # è¯¦ç»†è®¡ç®—è¿‡ç¨‹
        axes[1, 0].axis('off')
        axes[1, 0].text(0.5, 0.8, 'æ± åŒ–è®¡ç®—ç¤ºä¾‹', ha='center', va='center', 
                       transform=axes[1, 0].transAxes, fontsize=14, fontweight='bold')
        
        # é€‰æ‹©ä¸€ä¸ª2x2åŒºåŸŸè¿›è¡Œè¯¦ç»†è®¡ç®—
        sample_region = feature_map[0:2, 0:2]
        max_val = np.max(sample_region)
        avg_val = np.mean(sample_region)
        
        calculation_text = f"""å·¦ä¸Šè§’2Ã—2åŒºåŸŸ:
{sample_region}

æœ€å¤§æ± åŒ–: max({sample_region.flatten()}) = {max_val}
å¹³å‡æ± åŒ–: mean({sample_region.flatten()}) = {avg_val:.1f}
å…¨å±€å¹³å‡æ± åŒ–: {global_avg:.2f}"""
        
        axes[1, 0].text(0.5, 0.4, calculation_text, ha='center', va='center', 
                       transform=axes[1, 0].transAxes, fontsize=10, 
                       bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue"))
        
        # æ± åŒ–æ•ˆæœå¯¹æ¯”
        pooling_comparison = {
            'åŸå§‹': feature_map.size,
            'æœ€å¤§æ± åŒ–': max_pooled.size,
            'å¹³å‡æ± åŒ–': avg_pooled.size,
            'å…¨å±€å¹³å‡': 1
        }
        
        methods = list(pooling_comparison.keys())
        sizes = list(pooling_comparison.values())
        
        axes[1, 1].bar(methods, sizes, color=['blue', 'red', 'green', 'orange'], alpha=0.7)
        axes[1, 1].set_ylabel('å‚æ•°æ•°é‡')
        axes[1, 1].set_title('ä¸åŒæ± åŒ–æ–¹æ³•çš„å‚æ•°æ•°é‡å¯¹æ¯”', fontweight='bold')
        axes[1, 1].grid(True, alpha=0.3)
        
        # æ·»åŠ æ•°å€¼æ ‡æ³¨
        for i, v in enumerate(sizes):
            axes[1, 1].text(i, v + 1, str(v), ha='center', va='bottom', fontweight='bold')
        
        # æ± åŒ–ç‰¹æ€§å¯¹æ¯”è¡¨
        axes[1, 2].axis('off')
        properties = [
            ['æ± åŒ–æ–¹æ³•', 'è®¡ç®—å¤æ‚åº¦', 'ä¿¡æ¯ä¿ç•™', 'å¹³ç§»ä¸å˜æ€§', 'é€‚ç”¨åœºæ™¯'],
            ['æœ€å¤§æ± åŒ–', 'ä½', 'ä¿ç•™æœ€å¼ºç‰¹å¾', 'å¥½', 'ç‰¹å¾æ£€æµ‹'],
            ['å¹³å‡æ± åŒ–', 'ä½', 'ä¿ç•™å¹³å‡ä¿¡æ¯', 'å¥½', 'å¹³æ»‘ç‰¹å¾'],
            ['å…¨å±€å¹³å‡', 'æœ€ä½', 'å…¨å±€ç»Ÿè®¡', 'æœ€å¥½', 'åˆ†ç±»ä»»åŠ¡']
        ]
        
        table = axes[1, 2].table(cellText=properties[1:], colLabels=properties[0], 
                                cellLoc='center', loc='center')
        table.auto_set_font_size(False)
        table.set_fontsize(9)
        table.scale(1, 2)
        axes[1, 2].set_title('æ± åŒ–æ–¹æ³•ç‰¹æ€§å¯¹æ¯”', fontweight='bold', fontsize=12)
        
        plt.tight_layout()
        plt.show()
        
        print(f"\nğŸ“Š æ± åŒ–æ“ä½œåˆ†æ:")
        print(f"   åŸå§‹ç‰¹å¾å›¾å°ºå¯¸: {feature_map.shape}")
        print(f"   æœ€å¤§æ± åŒ–åå°ºå¯¸: {max_pooled.shape}")
        print(f"   å¹³å‡æ± åŒ–åå°ºå¯¸: {avg_pooled.shape}")
        print(f"   å‚æ•°å‡å°‘æ¯”ä¾‹: {(1 - max_pooled.size/feature_map.size)*100:.1f}%")
        
        return feature_map, max_pooled, avg_pooled
    
    def analyze_pooling_invariance(self):
        """åˆ†ææ± åŒ–çš„å¹³ç§»ä¸å˜æ€§"""
        print(f"\n{'='*80}")
        print(f"ğŸ”„ æ± åŒ–å¹³ç§»ä¸å˜æ€§åˆ†æ")
        print(f"{'='*80}")
        
        # åˆ›å»ºä¸€ä¸ªç®€å•çš„ç‰¹å¾å›¾
        original = np.zeros((6, 6))
        original[2:4, 2:4] = 5  # ä¸­å¿ƒæœ‰ä¸€ä¸ªäº®ç‚¹
        
        # åˆ›å»ºå¹³ç§»ç‰ˆæœ¬
        shifted = np.zeros((6, 6))
        shifted[2:4, 3:5] = 5  # å‘å³å¹³ç§»ä¸€ä¸ªåƒç´ 
        
        # å¯¹ä¸¤ä¸ªç‰ˆæœ¬è¿›è¡Œæ± åŒ–
        original_pooled = self.max_pooling(original, pool_size=2, stride=2)
        shifted_pooled = self.max_pooling(shifted, pool_size=2, stride=2)
        
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        
        # åŸå§‹å›¾åƒ
        axes[0, 0].imshow(original, cmap='viridis')
        axes[0, 0].set_title('åŸå§‹ç‰¹å¾å›¾', fontweight='bold')
        axes[0, 0].axis('off')
        
        # å¹³ç§»å›¾åƒ
        axes[0, 1].imshow(shifted, cmap='viridis')
        axes[0, 1].set_title('å¹³ç§»åç‰¹å¾å›¾', fontweight='bold')
        axes[0, 1].axis('off')
        
        # å·®å¼‚
        diff = np.abs(original - shifted)
        axes[0, 2].imshow(diff, cmap='Reds')
        axes[0, 2].set_title('å·®å¼‚å›¾', fontweight='bold')
        axes[0, 2].axis('off')
        
        # æ± åŒ–åçš„ç»“æœ
        axes[1, 0].imshow(original_pooled, cmap='viridis')
        axes[1, 0].set_title('åŸå§‹æ± åŒ–ç»“æœ', fontweight='bold')
        axes[1, 0].axis('off')
        
        axes[1, 1].imshow(shifted_pooled, cmap='viridis')
        axes[1, 1].set_title('å¹³ç§»åæ± åŒ–ç»“æœ', fontweight='bold')
        axes[1, 1].axis('off')
        
        # æ± åŒ–åçš„å·®å¼‚
        pooled_diff = np.abs(original_pooled - shifted_pooled)
        axes[1, 2].imshow(pooled_diff, cmap='Reds')
        axes[1, 2].set_title('æ± åŒ–åå·®å¼‚', fontweight='bold')
        axes[1, 2].axis('off')
        
        plt.tight_layout()
        plt.show()
        
        # è®¡ç®—ä¸å˜æ€§æŒ‡æ ‡
        original_diff = np.sum(diff)
        pooled_diff_sum = np.sum(pooled_diff)
        
        print(f"\nğŸ“ˆ å¹³ç§»ä¸å˜æ€§åˆ†æ:")
        print(f"   åŸå§‹å›¾åƒå·®å¼‚æ€»å’Œ: {original_diff}")
        print(f"   æ± åŒ–åå·®å¼‚æ€»å’Œ: {pooled_diff_sum}")
        print(f"   ä¸å˜æ€§æå‡: {(1 - pooled_diff_sum/original_diff)*100:.1f}%")
        
        return original, shifted, original_pooled, shifted_pooled

# æ± åŒ–æ“ä½œæ¼”ç¤º
print("\n" + "=" * 80)
print("ğŸŠ æ± åŒ–æ“ä½œè¯¦è§£")
print("=" * 80)

pool_demo = PoolingDemo()

# æ¼”ç¤ºæ± åŒ–æ“ä½œ
feature_map, max_pooled, avg_pooled = pool_demo.demonstrate_pooling_operations()

# åˆ†æå¹³ç§»ä¸å˜æ€§
original, shifted, original_pooled, shifted_pooled = pool_demo.analyze_pooling_invariance()
```

## 3. å®Œæ•´çš„CNNå®ç°

### 3.1 ç®€å•CNNåˆ†ç±»å™¨

```python
class SimpleCNN:
    """ç®€å•çš„CNNå®ç°"""
    
    def __init__(self, input_shape, num_classes):
        self.input_shape = input_shape  # (height, width, channels)
        self.num_classes = num_classes
        
        # åˆå§‹åŒ–ç½‘ç»œå‚æ•°
        self.initialize_parameters()
        
        # è®­ç»ƒå†å²
        self.training_history = {'losses': [], 'accuracies': []}
    
    def initialize_parameters(self):
        """åˆå§‹åŒ–ç½‘ç»œå‚æ•°"""
        np.random.seed(42)
        
        # å·ç§¯å±‚1: 32ä¸ª3x3å·ç§¯æ ¸
        self.conv1_filters = np.random.randn(32, 3, 3, self.input_shape[2]) * 0.1
        self.conv1_bias = np.zeros((32,))
        
        # å·ç§¯å±‚2: 64ä¸ª3x3å·ç§¯æ ¸
        self.conv2_filters = np.random.randn(64, 3, 3, 32) * 0.1
        self.conv2_bias = np.zeros((64,))
        
        # è®¡ç®—å…¨è¿æ¥å±‚è¾“å…¥å°ºå¯¸ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
        # å‡è®¾è¾“å…¥28x28ï¼Œç»è¿‡ä¸¤æ¬¡å·ç§¯å’Œæ± åŒ–åå˜ä¸º7x7
        fc_input_size = 7 * 7 * 64
        
        # å…¨è¿æ¥å±‚
        self.fc_weights = np.random.randn(fc_input_size, self.num_classes) * 0.1
        self.fc_bias = np.zeros((self.num_classes,))
    
    def relu(self, x):
        """ReLUæ¿€æ´»å‡½æ•°"""
        return np.maximum(0, x)
    
    def softmax(self, x):
        """Softmaxæ¿€æ´»å‡½æ•°"""
        exp_x = np.exp(x - np.max(x, axis=-1, keepdims=True))
        return exp_x / np.sum(exp_x, axis=-1, keepdims=True)
    
    def conv2d_simple(self, input_data, filters, bias, stride=1, padding=0):
        """ç®€åŒ–çš„2Då·ç§¯å®ç°"""
        batch_size, in_height, in_width, in_channels = input_data.shape
        num_filters, filter_height, filter_width, _ = filters.shape
        
        # è®¡ç®—è¾“å‡ºå°ºå¯¸
        out_height = (in_height + 2*padding - filter_height) // stride + 1
        out_width = (in_width + 2*padding - filter_width) // stride + 1
        
        # åˆå§‹åŒ–è¾“å‡º
        output = np.zeros((batch_size, out_height, out_width, num_filters))
        
        # æ·»åŠ padding
        if padding > 0:
            input_padded = np.pad(input_data, 
                                ((0, 0), (padding, padding), (padding, padding), (0, 0)), 
                                mode='constant')
        else:
            input_padded = input_data
        
        # æ‰§è¡Œå·ç§¯
        for b in range(batch_size):
            for f in range(num_filters):
                for i in range(0, out_height * stride, stride):
                    for j in range(0, out_width * stride, stride):
                        # æå–æ„Ÿå—é‡
                        receptive_field = input_padded[b, i:i+filter_height, j:j+filter_width, :]
                        # è®¡ç®—å·ç§¯
                        output[b, i//stride, j//stride, f] = \
                            np.sum(receptive_field * filters[f]) + bias[f]
        
        return output
    
    def max_pool2d(self, input_data, pool_size=2, stride=2):
        """2Dæœ€å¤§æ± åŒ–"""
        batch_size, in_height, in_width, channels = input_data.shape
        
        out_height = (in_height - pool_size) // stride + 1
        out_width = (in_width - pool_size) // stride + 1
        
        output = np.zeros((batch_size, out_height, out_width, channels))
        
        for b in range(batch_size):
            for c in range(channels):
                for i in range(0, out_height * stride, stride):
                    for j in range(0, out_width * stride, stride):
                        pool_region = input_data[b, i:i+pool_size, j:j+pool_size, c]
                        output[b, i//stride, j//stride, c] = np.max(pool_region)
        
        return output
    
    def forward(self, X):
        """å‰å‘ä¼ æ’­"""
        # ç¡®ä¿è¾“å…¥æ˜¯4Då¼ é‡ (batch_size, height, width, channels)
        if len(X.shape) == 3:
            X = X.reshape(1, *X.shape)
        
        # å·ç§¯å±‚1 + ReLU + æ± åŒ–
        conv1_out = self.conv2d_simple(X, self.conv1_filters, self.conv1_bias)
        relu1_out = self.relu(conv1_out)
        pool1_out = self.max_pool2d(relu1_out)
        
        # å·ç§¯å±‚2 + ReLU + æ± åŒ–
        conv2_out = self.conv2d_simple(pool1_out, self.conv2_filters, self.conv2_bias)
        relu2_out = self.relu(conv2_out)
        pool2_out = self.max_pool2d(relu2_out)
        
        # å±•å¹³
        flattened = pool2_out.reshape(pool2_out.shape[0], -1)
        
        # å…¨è¿æ¥å±‚
        fc_out = np.dot(flattened, self.fc_weights) + self.fc_bias
        
        # Softmax
        output = self.softmax(fc_out)
        
        # ä¿å­˜ä¸­é—´ç»“æœç”¨äºåå‘ä¼ æ’­
        self.cache = {
            'input': X,
            'conv1_out': conv1_out,
            'relu1_out': relu1_out,
            'pool1_out': pool1_out,
            'conv2_out': conv2_out,
            'relu2_out': relu2_out,
            'pool2_out': pool2_out,
            'flattened': flattened,
            'fc_out': fc_out,
            'output': output
        }
        
        return output
    
    def compute_loss(self, y_pred, y_true):
        """è®¡ç®—äº¤å‰ç†µæŸå¤±"""
        # é¿å…log(0)
        y_pred = np.clip(y_pred, 1e-15, 1 - 1e-15)
        return -np.mean(np.sum(y_true * np.log(y_pred), axis=1))
    
    def predict(self, X):
        """é¢„æµ‹"""
        return self.forward(X)
    
    def evaluate(self, X, y):
        """è¯„ä¼°æ¨¡å‹"""
        predictions = self.predict(X)
        
        # è®¡ç®—æŸå¤±
        loss = self.compute_loss(predictions, y)
        
        # è®¡ç®—å‡†ç¡®ç‡
        pred_classes = np.argmax(predictions, axis=1)
        true_classes = np.argmax(y, axis=1)
        accuracy = np.mean(pred_classes == true_classes)
        
        return loss, accuracy

class CNNVisualizer:
    """CNNå¯è§†åŒ–å·¥å…·"""
    
    def __init__(self, cnn_model):
        self.model = cnn_model
    
    def visualize_filters(self):
        """å¯è§†åŒ–å·ç§¯æ ¸"""
        print(f"\n{'='*80}")
        print(f"ğŸ” CNNå·ç§¯æ ¸å¯è§†åŒ–")
        print(f"{'='*80}")
        
        # å¯è§†åŒ–ç¬¬ä¸€å±‚å·ç§¯æ ¸
        conv1_filters = self.model.conv1_filters
        num_filters = min(16, conv1_filters.shape[0])  # æœ€å¤šæ˜¾ç¤º16ä¸ª
        
        fig, axes = plt.subplots(4, 4, figsize=(12, 12))
        axes = axes.flatten()
        
        for i in range(num_filters):
            # å¦‚æœæ˜¯å¤šé€šé“ï¼Œå–ç¬¬ä¸€ä¸ªé€šé“æˆ–å¹³å‡
            if conv1_filters.shape[3] == 1:
                filter_img = conv1_filters[i, :, :, 0]
            else:
                filter_img = np.mean(conv1_filters[i, :, :, :], axis=2)
            
            im = axes[i].imshow(filter_img, cmap='RdBu')
            axes[i].set_title(f'Filter {i+1}', fontsize=10)
            axes[i].axis('off')
            plt.colorbar(im, ax=axes[i], fraction=0.046, pad=0.04)
        
        plt.suptitle('ç¬¬ä¸€å±‚å·ç§¯æ ¸å¯è§†åŒ–', fontsize=16, fontweight='bold')
        plt.tight_layout()
        plt.show()
        
        return fig
    
    def visualize_feature_maps(self, input_image):
        """å¯è§†åŒ–ç‰¹å¾å›¾"""
        print(f"\n{'='*80}")
        print(f"ğŸ—ºï¸ ç‰¹å¾å›¾å¯è§†åŒ–")
        print(f"{'='*80}")
        
        # å‰å‘ä¼ æ’­è·å–ä¸­é—´ç»“æœ
        _ = self.model.forward(input_image)
        cache = self.model.cache
        
        # å¯è§†åŒ–ä¸åŒå±‚çš„ç‰¹å¾å›¾
        layers_to_visualize = [
            ('è¾“å…¥å›¾åƒ', cache['input'][0]),
            ('å·ç§¯å±‚1è¾“å‡º', cache['conv1_out'][0]),
            ('ReLU1è¾“å‡º', cache['relu1_out'][0]),
            ('æ± åŒ–å±‚1è¾“å‡º', cache['pool1_out'][0]),
            ('å·ç§¯å±‚2è¾“å‡º', cache['conv2_out'][0]),
            ('æ± åŒ–å±‚2è¾“å‡º', cache['pool2_out'][0])
        ]
        
        fig, axes = plt.subplots(2, 3, figsize=(18, 12))
        axes = axes.flatten()
        
        for idx, (layer_name, feature_map) in enumerate(layers_to_visualize):
            if len(feature_map.shape) == 3:  # å¤šé€šé“
                if feature_map.shape[2] == 1:
                    # å•é€šé“
                    display_map = feature_map[:, :, 0]
                elif feature_map.shape[2] == 3:
                    # RGBå›¾åƒ
                    display_map = feature_map
                else:
                    # å¤šé€šé“ï¼Œæ˜¾ç¤ºå‰å‡ ä¸ªé€šé“çš„å¹³å‡
                    display_map = np.mean(feature_map[:, :, :min(8, feature_map.shape[2])], axis=2)
            else:
                display_map = feature_map
            
            if len(display_map.shape) == 3 and display_map.shape[2] == 3:
                axes[idx].imshow(display_map)
            else:
                im = axes[idx].imshow(display_map, cmap='viridis')
                plt.colorbar(im, ax=axes[idx], fraction=0.046, pad=0.04)
            
            axes[idx].set_title(f'{layer_name}\nå½¢çŠ¶: {feature_map.shape}', fontweight='bold')
            axes[idx].axis('off')
        
        plt.tight_layout()
        plt.show()
        
        return fig
    
    def analyze_network_architecture(self):
        """åˆ†æç½‘ç»œæ¶æ„"""
        print(f"\n{'='*80}")
        print(f"ğŸ—ï¸ CNNç½‘ç»œæ¶æ„åˆ†æ")
        print(f"{'='*80}")
        
        # è®¡ç®—æ¯å±‚çš„å‚æ•°æ•°é‡
        conv1_params = np.prod(self.model.conv1_filters.shape) + len(self.model.conv1_bias)
        conv2_params = np.prod(self.model.conv2_filters.shape) + len(self.model.conv2_bias)
        fc_params = np.prod(self.model.fc_weights.shape) + len(self.model.fc_bias)
        
        total_params = conv1_params + conv2_params + fc_params
        
        print(f"\nğŸ“Š ç½‘ç»œå‚æ•°ç»Ÿè®¡:")
        print(f"   å·ç§¯å±‚1å‚æ•°: {conv1_params:,}")
        print(f"   å·ç§¯å±‚2å‚æ•°: {conv2_params:,}")
        print(f"   å…¨è¿æ¥å±‚å‚æ•°: {fc_params:,}")
        print(f"   æ€»å‚æ•°æ•°é‡: {total_params:,}")
        
        # å¯è§†åŒ–ç½‘ç»œæ¶æ„
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        # å‚æ•°åˆ†å¸ƒé¥¼å›¾
        labels = ['å·ç§¯å±‚1', 'å·ç§¯å±‚2', 'å…¨è¿æ¥å±‚']
        sizes = [conv1_params, conv2_params, fc_params]
        colors = ['lightblue', 'lightgreen', 'lightcoral']
        
        ax1.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
        ax1.set_title('å‚æ•°åˆ†å¸ƒ', fontweight='bold')
        
        # ç½‘ç»œå±‚æ¬¡ç»“æ„
        layers = ['è¾“å…¥\n28Ã—28Ã—1', 'å·ç§¯1\n26Ã—26Ã—32', 'æ± åŒ–1\n13Ã—13Ã—32', 
                 'å·ç§¯2\n11Ã—11Ã—64', 'æ± åŒ–2\n5Ã—5Ã—64', 'å…¨è¿æ¥\n10']
        y_pos = np.arange(len(layers))
        
        ax2.barh(y_pos, [784, 21632, 5408, 7744, 1600, 10], color=colors*2)
        ax2.set_yticks(y_pos)
        ax2.set_yticklabels(layers)
        ax2.set_xlabel('ç‰¹å¾æ•°é‡')
        ax2.set_title('å„å±‚ç‰¹å¾æ•°é‡', fontweight='bold')
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
        
        return total_params

# CNNå®ç°æ¼”ç¤º
print("\n" + "=" * 80)
print("ğŸ§  å®Œæ•´CNNå®ç°æ¼”ç¤º")
print("=" * 80)

# ä½¿ç”¨æ‰‹å†™æ•°å­—æ•°æ®é›†è¿›è¡Œæ¼”ç¤º
digits = load_digits()
X, y = digits.data, digits.target

# é‡å¡‘æ•°æ®ä¸ºå›¾åƒæ ¼å¼
X = X.reshape(-1, 8, 8, 1)  # 8x8ç°åº¦å›¾åƒ
X = X.astype(np.float32) / 16.0  # å½’ä¸€åŒ–åˆ°[0,1]

# è½¬æ¢æ ‡ç­¾ä¸ºone-hotç¼–ç 
y_onehot = np.eye(10)[y]

# åˆ’åˆ†è®­ç»ƒé›†å’Œæµ‹è¯•é›†
X_train, X_test, y_train, y_test = train_test_split(X, y_onehot, test_size=0.2, random_state=42)

print(f"\nğŸ“Š æ•°æ®é›†ä¿¡æ¯:")
print(f"   è®­ç»ƒé›†å¤§å°: {X_train.shape}")
print(f"   æµ‹è¯•é›†å¤§å°: {X_test.shape}")
print(f"   ç±»åˆ«æ•°é‡: {y_onehot.shape[1]}")

# åˆ›å»ºCNNæ¨¡å‹
cnn = SimpleCNN(input_shape=(8, 8, 1), num_classes=10)

# åˆ›å»ºå¯è§†åŒ–å·¥å…·
visualizer = CNNVisualizer(cnn)

# å¯è§†åŒ–å·ç§¯æ ¸
filter_fig = visualizer.visualize_filters()

# é€‰æ‹©ä¸€ä¸ªæ ·æœ¬è¿›è¡Œç‰¹å¾å›¾å¯è§†åŒ–
sample_image = X_train[0:1]  # å–ç¬¬ä¸€ä¸ªæ ·æœ¬
feature_map_fig = visualizer.visualize_feature_maps(sample_image)

# åˆ†æç½‘ç»œæ¶æ„
total_params = visualizer.analyze_network_architecture()

# æµ‹è¯•å‰å‘ä¼ æ’­
print(f"\nğŸ”„ æµ‹è¯•å‰å‘ä¼ æ’­:")
test_input = X_train[:5]  # å–å‰5ä¸ªæ ·æœ¬
predictions = cnn.predict(test_input)

print(f"   è¾“å…¥å½¢çŠ¶: {test_input.shape}")
print(f"   è¾“å‡ºå½¢çŠ¶: {predictions.shape}")
print(f"   é¢„æµ‹ç±»åˆ«: {np.argmax(predictions, axis=1)}")
print(f"   çœŸå®ç±»åˆ«: {np.argmax(y_train[:5], axis=1)}")

# è¯„ä¼°åˆå§‹æ€§èƒ½
initial_loss, initial_acc = cnn.evaluate(X_test, y_test)
print(f"\nğŸ“ˆ åˆå§‹æ€§èƒ½:")
print(f"   æµ‹è¯•æŸå¤±: {initial_loss:.4f}")
print(f"   æµ‹è¯•å‡†ç¡®ç‡: {initial_acc:.4f}")

print(f"\nâœ… CNNå®ç°æ¼”ç¤ºå®Œæˆ!")
```

## 4. æ€è€ƒé¢˜

1. **å·ç§¯æ ¸è®¾è®¡**: ä¸åŒçš„å·ç§¯æ ¸èƒ½å¤Ÿæ£€æµ‹ä»€ä¹ˆæ ·çš„ç‰¹å¾ï¼Ÿå¦‚ä½•è®¾è®¡å·ç§¯æ ¸æ¥æ£€æµ‹ç‰¹å®šçš„å›¾åƒç‰¹å¾ï¼Ÿ

2. **å‚æ•°å…±äº«**: CNNä¸­çš„å‚æ•°å…±äº«æœºåˆ¶æœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿä¸å…¨è¿æ¥ç½‘ç»œç›¸æ¯”ï¼Œå‚æ•°æ•°é‡å‡å°‘äº†å¤šå°‘ï¼Ÿ

3. **æ„Ÿå—é‡**: å¦‚ä½•è®¡ç®—CNNä¸­æŸä¸€å±‚ç¥ç»å…ƒçš„æ„Ÿå—é‡å¤§å°ï¼Ÿæ·±å±‚ç½‘ç»œçš„æ„Ÿå—é‡æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Ÿ

4. **æ± åŒ–é€‰æ‹©**: åœ¨ä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥ä½¿ç”¨æœ€å¤§æ± åŒ–ï¼Ÿä»€ä¹ˆæƒ…å†µä¸‹ä½¿ç”¨å¹³å‡æ± åŒ–ï¼Ÿå…¨å±€å¹³å‡æ± åŒ–æœ‰ä»€ä¹ˆç‰¹æ®Šç”¨é€”ï¼Ÿ

5. **ç½‘ç»œè®¾è®¡**: å¦‚ä½•æ ¹æ®å…·ä½“ä»»åŠ¡è®¾è®¡CNNæ¶æ„ï¼Ÿå·ç§¯å±‚æ•°ã€å·ç§¯æ ¸å¤§å°ã€æ­¥é•¿ç­‰è¶…å‚æ•°å¦‚ä½•é€‰æ‹©ï¼Ÿ

## 5. å°ç»“

### 5.1 æ ¸å¿ƒæ¦‚å¿µ

- **å·ç§¯æ“ä½œ**: é€šè¿‡å·ç§¯æ ¸æå–å±€éƒ¨ç‰¹å¾çš„æ ¸å¿ƒæ“ä½œ
- **å‚æ•°å…±äº«**: åŒä¸€å·ç§¯æ ¸åœ¨æ•´ä¸ªè¾“å…¥ä¸Šå…±äº«å‚æ•°
- **å±€éƒ¨è¿æ¥**: æ¯ä¸ªç¥ç»å…ƒåªä¸å±€éƒ¨åŒºåŸŸè¿æ¥
- **æ± åŒ–æ“ä½œ**: é™ä½ç©ºé—´åˆ†è¾¨ç‡ï¼Œæä¾›å¹³ç§»ä¸å˜æ€§
- **å±‚æ¬¡ç‰¹å¾**: ä»ä½çº§åˆ°é«˜çº§ç‰¹å¾çš„é€å±‚æŠ½è±¡

### 5.2 å…³é”®æŠ€æœ¯

- **å·ç§¯æ ¸è®¾è®¡**: ä¸åŒå·ç§¯æ ¸æ£€æµ‹ä¸åŒç±»å‹çš„ç‰¹å¾
- **æ­¥é•¿å’Œå¡«å……**: æ§åˆ¶è¾“å‡ºå°ºå¯¸çš„é‡è¦å‚æ•°
- **æ¿€æ´»å‡½æ•°**: é€šå¸¸ä½¿ç”¨ReLUåŠå…¶å˜ä½“
- **æ± åŒ–ç­–ç•¥**: æœ€å¤§æ± åŒ–ã€å¹³å‡æ± åŒ–ã€å…¨å±€æ± åŒ–
- **ç½‘ç»œæ¶æ„**: å·ç§¯å±‚ã€æ± åŒ–å±‚ã€å…¨è¿æ¥å±‚çš„ç»„åˆ

### 5.3 å®è·µè¦ç‚¹

- æ ¹æ®ä»»åŠ¡ç‰¹ç‚¹è®¾è®¡åˆé€‚çš„ç½‘ç»œæ¶æ„
- åˆç†é€‰æ‹©å·ç§¯æ ¸å¤§å°ã€æ•°é‡å’Œæ­¥é•¿
- æ³¨æ„æ¢¯åº¦æ¶ˆå¤±é—®é¢˜ï¼Œä½¿ç”¨åˆé€‚çš„æ¿€æ´»å‡½æ•°
- åˆ©ç”¨æ•°æ®å¢å¼ºæé«˜æ¨¡å‹æ³›åŒ–èƒ½åŠ›
- ç›‘æ§è®­ç»ƒè¿‡ç¨‹ï¼Œé˜²æ­¢è¿‡æ‹Ÿåˆ

### 5.4 åº”ç”¨åœºæ™¯

- **å›¾åƒåˆ†ç±»**: è¯†åˆ«å›¾åƒä¸­çš„å¯¹è±¡ç±»åˆ«
- **ç›®æ ‡æ£€æµ‹**: å®šä½å’Œè¯†åˆ«å›¾åƒä¸­çš„å¤šä¸ªå¯¹è±¡
- **å›¾åƒåˆ†å‰²**: åƒç´ çº§åˆ«çš„å›¾åƒç†è§£
- **é£æ ¼è¿ç§»**: å›¾åƒé£æ ¼è½¬æ¢
- **åŒ»å­¦å½±åƒ**: åŒ»å­¦å›¾åƒåˆ†æå’Œè¯Šæ–­

é€šè¿‡æœ¬èŠ‚çš„å­¦ä¹ ï¼Œä½ å·²ç»æ·±å…¥ç†è§£äº†å·ç§¯ç¥ç»ç½‘ç»œçš„æ ¸å¿ƒåŸç†å’Œå®ç°æ–¹æ³•ï¼Œè¿™ä¸ºä½ è¿›ä¸€æ­¥å­¦ä¹ æ›´é«˜çº§çš„æ·±åº¦å­¦ä¹ æŠ€æœ¯å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚