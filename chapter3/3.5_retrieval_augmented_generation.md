# 3.5 æ£€ç´¢å¢å¼ºç”Ÿæˆ (Retrieval-Augmented Generation, RAG)

> "RAGæŠ€æœ¯å°†å¤§è¯­è¨€æ¨¡å‹çš„ç”Ÿæˆèƒ½åŠ›ä¸å¤–éƒ¨çŸ¥è¯†åº“çš„æ£€ç´¢èƒ½åŠ›ç›¸ç»“åˆï¼Œä¸ºAIç³»ç»Ÿæ³¨å…¥äº†å®æ—¶ã€å‡†ç¡®çš„çŸ¥è¯†æ›´æ–°èƒ½åŠ›ã€‚" â€”â€” RAGæŠ€æœ¯ä¸“å®¶

---

## 3.5.1 RAGæ¶æ„åŸç†ä¸æ ¸å¿ƒæ¦‚å¿µ

### RAGçš„æ ¸å¿ƒæ€æƒ³

RAGé€šè¿‡å°†æ£€ç´¢ç³»ç»Ÿä¸ç”Ÿæˆæ¨¡å‹ç›¸ç»“åˆï¼Œä½¿AIèƒ½å¤Ÿè®¿é—®å’Œåˆ©ç”¨å¤–éƒ¨çŸ¥è¯†åº“ä¸­çš„ä¿¡æ¯ï¼Œä»è€Œç”Ÿæˆæ›´å‡†ç¡®ã€æ›´å…·æ—¶æ•ˆæ€§çš„å›ç­”ã€‚

```python
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from matplotlib.patches import FancyBboxPatch, Rectangle, Circle, Arrow
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
import warnings
warnings.filterwarnings('ignore')

# è®¾ç½®ä¸­æ–‡å­—ä½“
plt.rcParams['font.sans-serif'] = ['SimHei', 'Arial Unicode MS', 'DejaVu Sans']
plt.rcParams['axes.unicode_minus'] = False

class RAGArchitectureAnalyzer:
    def __init__(self):
        self.rag_components = {
            'çŸ¥è¯†åº“': 'å­˜å‚¨ç»“æ„åŒ–å’Œéç»“æ„åŒ–çš„å¤–éƒ¨çŸ¥è¯†',
            'å‘é‡åŒ–': 'å°†æ–‡æœ¬è½¬æ¢ä¸ºé«˜ç»´å‘é‡è¡¨ç¤º',
            'æ£€ç´¢å™¨': 'æ ¹æ®æŸ¥è¯¢æ‰¾åˆ°ç›¸å…³çš„çŸ¥è¯†ç‰‡æ®µ',
            'ç”Ÿæˆå™¨': 'åŸºäºæ£€ç´¢ç»“æœç”Ÿæˆæœ€ç»ˆå›ç­”',
            'èåˆæ¨¡å—': 'æ•´åˆæ£€ç´¢ä¿¡æ¯å’Œç”Ÿæˆé€»è¾‘'
        }
        
    def demonstrate_rag_architecture(self):
        """æ¼”ç¤ºRAGæ¶æ„å›¾"""
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 10))
        fig.suptitle('RAGæ¶æ„åŸç†ä¸å·¥ä½œæµç¨‹', fontsize=16, fontweight='bold')
        
        # RAGæ¶æ„å›¾
        ax1.set_xlim(0, 10)
        ax1.set_ylim(0, 10)
        ax1.set_title('RAGç³»ç»Ÿæ¶æ„', fontsize=14, fontweight='bold')
        
        # ç»˜åˆ¶ç»„ä»¶
        components = [
            {'name': 'ç”¨æˆ·æŸ¥è¯¢', 'pos': (1, 8), 'size': (1.5, 0.8), 'color': 'lightblue'},
            {'name': 'æŸ¥è¯¢ç¼–ç ', 'pos': (1, 6.5), 'size': (1.5, 0.8), 'color': 'lightgreen'},
            {'name': 'çŸ¥è¯†åº“', 'pos': (5, 8), 'size': (2, 1.5), 'color': 'lightyellow'},
            {'name': 'å‘é‡æ£€ç´¢', 'pos': (5, 6), 'size': (2, 0.8), 'color': 'lightcoral'},
            {'name': 'ç›¸å…³æ–‡æ¡£', 'pos': (5, 4.5), 'size': (2, 0.8), 'color': 'lightgray'},
            {'name': 'ä¸Šä¸‹æ–‡èåˆ', 'pos': (1, 3), 'size': (1.5, 0.8), 'color': 'plum'},
            {'name': 'ç”Ÿæˆæ¨¡å‹', 'pos': (1, 1.5), 'size': (1.5, 0.8), 'color': 'orange'},
            {'name': 'æœ€ç»ˆå›ç­”', 'pos': (5, 1.5), 'size': (1.5, 0.8), 'color': 'lightsteelblue'}
        ]
        
        for comp in components:
            rect = FancyBboxPatch(
                comp['pos'], comp['size'][0], comp['size'][1],
                boxstyle="round,pad=0.1", 
                facecolor=comp['color'], 
                edgecolor='black', 
                linewidth=2
            )
            ax1.add_patch(rect)
            ax1.text(
                comp['pos'][0] + comp['size'][0]/2, 
                comp['pos'][1] + comp['size'][1]/2,
                comp['name'], 
                ha='center', va='center', 
                fontsize=10, fontweight='bold'
            )
        
        # ç»˜åˆ¶ç®­å¤´è¿æ¥
        arrows = [
            ((1.75, 7.7), (1.75, 7.3)),  # ç”¨æˆ·æŸ¥è¯¢ -> æŸ¥è¯¢ç¼–ç 
            ((2.5, 6.9), (5, 6.4)),       # æŸ¥è¯¢ç¼–ç  -> å‘é‡æ£€ç´¢
            ((6, 7.5), (6, 6.8)),         # çŸ¥è¯†åº“ -> å‘é‡æ£€ç´¢
            ((6, 5.8), (6, 5.3)),         # å‘é‡æ£€ç´¢ -> ç›¸å…³æ–‡æ¡£
            ((5, 4.9), (2.5, 3.4)),       # ç›¸å…³æ–‡æ¡£ -> ä¸Šä¸‹æ–‡èåˆ
            ((1.75, 2.8), (1.75, 2.3)),   # ä¸Šä¸‹æ–‡èåˆ -> ç”Ÿæˆæ¨¡å‹
            ((2.5, 1.9), (5, 1.9))        # ç”Ÿæˆæ¨¡å‹ -> æœ€ç»ˆå›ç­”
        ]
        
        for start, end in arrows:
            ax1.annotate('', xy=end, xytext=start,
                        arrowprops=dict(arrowstyle='->', lw=2, color='red'))
        
        ax1.axis('off')
        
        # RAG vs ä¼ ç»ŸLLMå¯¹æ¯”
        comparison_metrics = ['å‡†ç¡®æ€§', 'æ—¶æ•ˆæ€§', 'å¯è§£é‡Šæ€§', 'çŸ¥è¯†è¦†ç›–', 'è®¡ç®—æˆæœ¬']
        traditional_llm = [0.7, 0.5, 0.6, 0.8, 0.9]
        rag_system = [0.9, 0.95, 0.85, 0.95, 0.7]
        
        x = np.arange(len(comparison_metrics))
        width = 0.35
        
        bars1 = ax2.bar(x - width/2, traditional_llm, width, 
                       label='ä¼ ç»ŸLLM', color='lightcoral', alpha=0.8)
        bars2 = ax2.bar(x + width/2, rag_system, width, 
                       label='RAGç³»ç»Ÿ', color='lightgreen', alpha=0.8)
        
        ax2.set_xlabel('è¯„ä¼°æŒ‡æ ‡')
        ax2.set_ylabel('è¯„åˆ†')
        ax2.set_title('RAG vs ä¼ ç»ŸLLMæ€§èƒ½å¯¹æ¯”', fontweight='bold')
        ax2.set_xticks(x)
        ax2.set_xticklabels(comparison_metrics, rotation=45, ha='right')
        ax2.legend()
        ax2.set_ylim(0, 1)
        
        # æ·»åŠ æ•°å€¼æ ‡ç­¾
        for bars in [bars1, bars2]:
            for bar in bars:
                height = bar.get_height()
                ax2.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                        f'{height:.2f}', ha='center', va='bottom', fontsize=9)
        
        plt.tight_layout()
        plt.show()
    
    def analyze_rag_workflow(self):
        """åˆ†æRAGå·¥ä½œæµç¨‹"""
        workflow_steps = {
            '1. æŸ¥è¯¢å¤„ç†': {
                'æè¿°': 'å¯¹ç”¨æˆ·æŸ¥è¯¢è¿›è¡Œé¢„å¤„ç†å’Œç†è§£',
                'æŠ€æœ¯': 'æŸ¥è¯¢æ‰©å±•ã€æ„å›¾è¯†åˆ«ã€å…³é”®è¯æå–',
                'æ—¶é—´': 0.1,
                'é‡è¦æ€§': 0.8
            },
            '2. å‘é‡æ£€ç´¢': {
                'æè¿°': 'åœ¨å‘é‡ç©ºé—´ä¸­æœç´¢ç›¸å…³æ–‡æ¡£',
                'æŠ€æœ¯': 'è¯­ä¹‰ç›¸ä¼¼åº¦è®¡ç®—ã€è¿‘ä¼¼æœ€è¿‘é‚»æœç´¢',
                'æ—¶é—´': 0.3,
                'é‡è¦æ€§': 0.95
            },
            '3. æ–‡æ¡£æ’åº': {
                'æè¿°': 'å¯¹æ£€ç´¢ç»“æœè¿›è¡Œç›¸å…³æ€§æ’åº',
                'æŠ€æœ¯': 'é‡æ’åºç®—æ³•ã€ç›¸å…³æ€§è¯„åˆ†',
                'æ—¶é—´': 0.2,
                'é‡è¦æ€§': 0.85
            },
            '4. ä¸Šä¸‹æ–‡æ„å»º': {
                'æè¿°': 'å°†æ£€ç´¢æ–‡æ¡£æ•´åˆä¸ºç”Ÿæˆä¸Šä¸‹æ–‡',
                'æŠ€æœ¯': 'æ–‡æ¡£æˆªæ–­ã€ä¿¡æ¯èåˆã€å»é‡',
                'æ—¶é—´': 0.15,
                'é‡è¦æ€§': 0.9
            },
            '5. ç­”æ¡ˆç”Ÿæˆ': {
                'æè¿°': 'åŸºäºä¸Šä¸‹æ–‡ç”Ÿæˆæœ€ç»ˆå›ç­”',
                'æŠ€æœ¯': 'æ¡ä»¶ç”Ÿæˆã€ä¸€è‡´æ€§æ£€æŸ¥',
                'æ—¶é—´': 0.8,
                'é‡è¦æ€§': 0.92
            },
            '6. åå¤„ç†': {
                'æè¿°': 'å¯¹ç”Ÿæˆç»“æœè¿›è¡Œä¼˜åŒ–å’ŒéªŒè¯',
                'æŠ€æœ¯': 'äº‹å®æ£€æŸ¥ã€æ ¼å¼åŒ–ã€è´¨é‡è¯„ä¼°',
                'æ—¶é—´': 0.1,
                'é‡è¦æ€§': 0.75
            }
        }
        
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('RAGå·¥ä½œæµç¨‹åˆ†æ', fontsize=16, fontweight='bold')
        
        # æ—¶é—´åˆ†å¸ƒ
        steps = list(workflow_steps.keys())
        times = [workflow_steps[step]['æ—¶é—´'] for step in steps]
        
        wedges, texts, autotexts = ax1.pie(times, labels=steps, autopct='%1.1f%%',
                                          startangle=90, colors=plt.cm.Set3(np.linspace(0, 1, len(steps))))
        ax1.set_title('å„æ­¥éª¤æ—¶é—´åˆ†å¸ƒ', fontweight='bold')
        
        # é‡è¦æ€§è¯„åˆ†
        importance = [workflow_steps[step]['é‡è¦æ€§'] for step in steps]
        
        bars = ax2.barh(steps, importance, color=plt.cm.viridis(np.array(importance)))
        ax2.set_xlabel('é‡è¦æ€§è¯„åˆ†')
        ax2.set_title('å„æ­¥éª¤é‡è¦æ€§è¯„ä¼°', fontweight='bold')
        ax2.set_xlim(0, 1)
        
        for bar, imp in zip(bars, importance):
            width = bar.get_width()
            ax2.text(width + 0.01, bar.get_y() + bar.get_height()/2,
                    f'{imp:.2f}', ha='left', va='center', fontweight='bold')
        
        # æ—¶é—´-é‡è¦æ€§æ•£ç‚¹å›¾
        colors = plt.cm.plasma(np.array(importance))
        scatter = ax3.scatter(times, importance, s=200, c=colors, alpha=0.7, edgecolors='black')
        
        for i, step in enumerate(steps):
            ax3.annotate(step.split('.')[1].strip(), (times[i], importance[i]), 
                        xytext=(5, 5), textcoords='offset points', fontsize=9)
        
        ax3.set_xlabel('æ‰§è¡Œæ—¶é—´(ç§’)')
        ax3.set_ylabel('é‡è¦æ€§è¯„åˆ†')
        ax3.set_title('æ—¶é—´-é‡è¦æ€§å…³ç³»åˆ†æ', fontweight='bold')
        ax3.grid(True, alpha=0.3)
        
        # ä¼˜åŒ–æ½œåŠ›åˆ†æ
        optimization_potential = []
        for step in steps:
            time_cost = workflow_steps[step]['æ—¶é—´']
            importance = workflow_steps[step]['é‡è¦æ€§']
            # é«˜æ—¶é—´æˆæœ¬ã€ä½é‡è¦æ€§çš„æ­¥éª¤æœ‰æ›´å¤§ä¼˜åŒ–æ½œåŠ›
            potential = time_cost * (1 - importance)
            optimization_potential.append(potential)
        
        bars = ax4.bar(range(len(steps)), optimization_potential, 
                      color=plt.cm.coolwarm(np.array(optimization_potential)/max(optimization_potential)))
        ax4.set_xlabel('å·¥ä½œæµç¨‹æ­¥éª¤')
        ax4.set_ylabel('ä¼˜åŒ–æ½œåŠ›')
        ax4.set_title('å„æ­¥éª¤ä¼˜åŒ–æ½œåŠ›åˆ†æ', fontweight='bold')
        ax4.set_xticks(range(len(steps)))
        ax4.set_xticklabels([s.split('.')[0] for s in steps])
        
        for bar, pot in zip(bars, optimization_potential):
            height = bar.get_height()
            ax4.text(bar.get_x() + bar.get_width()/2., height + 0.001,
                    f'{pot:.3f}', ha='center', va='bottom', fontsize=9)
        
        plt.tight_layout()
        plt.show()
    
    def demonstrate_retrieval_methods(self):
        """æ¼”ç¤ºä¸åŒæ£€ç´¢æ–¹æ³•"""
        retrieval_methods = {
            'å…³é”®è¯æ£€ç´¢': {
                'åŸç†': 'åŸºäºè¯æ±‡åŒ¹é…çš„ä¼ ç»Ÿæ£€ç´¢',
                'ä¼˜åŠ¿': 'ç®€å•å¿«é€Ÿã€å¯è§£é‡Šæ€§å¼º',
                'åŠ£åŠ¿': 'æ— æ³•ç†è§£è¯­ä¹‰ã€å¬å›ç‡ä½',
                'å‡†ç¡®ç‡': 0.65,
                'å¬å›ç‡': 0.70,
                'é€Ÿåº¦': 0.95
            },
            'å‘é‡æ£€ç´¢': {
                'åŸç†': 'åŸºäºè¯­ä¹‰å‘é‡çš„ç›¸ä¼¼åº¦æ£€ç´¢',
                'ä¼˜åŠ¿': 'è¯­ä¹‰ç†è§£å¼ºã€å¬å›ç‡é«˜',
                'åŠ£åŠ¿': 'è®¡ç®—å¤æ‚ã€éœ€è¦å‘é‡åŒ–',
                'å‡†ç¡®ç‡': 0.85,
                'å¬å›ç‡': 0.88,
                'é€Ÿåº¦': 0.75
            },
            'æ··åˆæ£€ç´¢': {
                'åŸç†': 'ç»“åˆå…³é”®è¯å’Œå‘é‡æ£€ç´¢',
                'ä¼˜åŠ¿': 'å…¼é¡¾ç²¾ç¡®åŒ¹é…å’Œè¯­ä¹‰ç†è§£',
                'åŠ£åŠ¿': 'ç³»ç»Ÿå¤æ‚åº¦é«˜',
                'å‡†ç¡®ç‡': 0.90,
                'å¬å›ç‡': 0.92,
                'é€Ÿåº¦': 0.70
            },
            'é‡æ’åºæ£€ç´¢': {
                'åŸç†': 'å¤šé˜¶æ®µæ£€ç´¢å’Œé‡æ–°æ’åº',
                'ä¼˜åŠ¿': 'æ£€ç´¢è´¨é‡æœ€é«˜',
                'åŠ£åŠ¿': 'è®¡ç®—æˆæœ¬æœ€é«˜',
                'å‡†ç¡®ç‡': 0.95,
                'å¬å›ç‡': 0.90,
                'é€Ÿåº¦': 0.60
            }
        }
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))
        fig.suptitle('æ£€ç´¢æ–¹æ³•å¯¹æ¯”åˆ†æ', fontsize=16, fontweight='bold')
        
        # æ€§èƒ½é›·è¾¾å›¾
        methods = list(retrieval_methods.keys())
        metrics = ['å‡†ç¡®ç‡', 'å¬å›ç‡', 'é€Ÿåº¦']
        
        angles = np.linspace(0, 2 * np.pi, len(metrics), endpoint=False).tolist()
        angles += angles[:1]  # é—­åˆå›¾å½¢
        
        ax1 = plt.subplot(121, projection='polar')
        
        colors = ['red', 'blue', 'green', 'orange']
        for i, method in enumerate(methods):
            values = [retrieval_methods[method][metric] for metric in metrics]
            values += values[:1]  # é—­åˆå›¾å½¢
            
            ax1.plot(angles, values, 'o-', linewidth=2, 
                    label=method, color=colors[i])
            ax1.fill(angles, values, alpha=0.25, color=colors[i])
        
        ax1.set_xticks(angles[:-1])
        ax1.set_xticklabels(metrics)
        ax1.set_ylim(0, 1)
        ax1.set_title('æ£€ç´¢æ–¹æ³•æ€§èƒ½é›·è¾¾å›¾', fontweight='bold', pad=20)
        ax1.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))
        ax1.grid(True)
        
        # æ–¹æ³•é€‰æ‹©å†³ç­–æ ‘
        ax2.set_xlim(0, 10)
        ax2.set_ylim(0, 10)
        ax2.set_title('æ£€ç´¢æ–¹æ³•é€‰æ‹©æŒ‡å—', fontweight='bold')
        
        # å†³ç­–èŠ‚ç‚¹
        decisions = [
            {'text': 'æ€§èƒ½è¦æ±‚é«˜ï¼Ÿ', 'pos': (5, 8), 'size': (2, 1)},
            {'text': 'è®¡ç®—èµ„æºå……è¶³ï¼Ÿ', 'pos': (2, 6), 'size': (1.8, 0.8)},
            {'text': 'éœ€è¦å¯è§£é‡Šæ€§ï¼Ÿ', 'pos': (8, 6), 'size': (1.8, 0.8)},
            {'text': 'é‡æ’åºæ£€ç´¢', 'pos': (1, 4), 'size': (1.5, 0.8)},
            {'text': 'æ··åˆæ£€ç´¢', 'pos': (3, 4), 'size': (1.5, 0.8)},
            {'text': 'å‘é‡æ£€ç´¢', 'pos': (7, 4), 'size': (1.5, 0.8)},
            {'text': 'å…³é”®è¯æ£€ç´¢', 'pos': (9, 4), 'size': (1.5, 0.8)}
        ]
        
        for i, decision in enumerate(decisions):
            if i < 3:  # å†³ç­–èŠ‚ç‚¹
                shape = Circle((decision['pos'][0], decision['pos'][1]), 0.8, 
                              facecolor='lightblue', edgecolor='black')
            else:  # ç»“æœèŠ‚ç‚¹
                shape = Rectangle((decision['pos'][0]-0.75, decision['pos'][1]-0.4), 
                                1.5, 0.8, facecolor='lightgreen', edgecolor='black')
            
            ax2.add_patch(shape)
            ax2.text(decision['pos'][0], decision['pos'][1], decision['text'],
                    ha='center', va='center', fontsize=9, fontweight='bold')
        
        # è¿æ¥çº¿
        connections = [
            ((5, 7.2), (2, 6.8), 'æ˜¯'),
            ((5, 7.2), (8, 6.8), 'å¦'),
            ((2, 5.2), (1, 4.8), 'æ˜¯'),
            ((2, 5.2), (3, 4.8), 'å¦'),
            ((8, 5.2), (7, 4.8), 'å¦'),
            ((8, 5.2), (9, 4.8), 'æ˜¯')
        ]
        
        for start, end, label in connections:
            ax2.annotate('', xy=end, xytext=start,
                        arrowprops=dict(arrowstyle='->', lw=1.5, color='red'))
            # æ·»åŠ æ ‡ç­¾
            mid_x, mid_y = (start[0] + end[0])/2, (start[1] + end[1])/2
            ax2.text(mid_x, mid_y, label, ha='center', va='center', 
                    fontsize=8, bbox=dict(boxstyle="round,pad=0.2", facecolor='white'))
        
        ax2.axis('off')
        
        plt.tight_layout()
        plt.show()

# æ¼”ç¤ºRAGæ¶æ„åˆ†æ
rag_analyzer = RAGArchitectureAnalyzer()
rag_analyzer.demonstrate_rag_architecture()
rag_analyzer.analyze_rag_workflow()
rag_analyzer.demonstrate_retrieval_methods()

print("\n=== RAGæ ¸å¿ƒæ¦‚å¿µ ===")
core_concepts = {
    "RAGå®šä¹‰": "ç»“åˆæ£€ç´¢å’Œç”Ÿæˆçš„æ··åˆAIæ¶æ„",
    "æ ¸å¿ƒä¼˜åŠ¿": "å®æ—¶çŸ¥è¯†æ›´æ–°ã€æé«˜å‡†ç¡®æ€§ã€å¢å¼ºå¯è§£é‡Šæ€§",
    "å…³é”®ç»„ä»¶": "çŸ¥è¯†åº“ã€æ£€ç´¢å™¨ã€ç”Ÿæˆå™¨ã€èåˆæ¨¡å—",
    "åº”ç”¨åœºæ™¯": "é—®ç­”ç³»ç»Ÿã€çŸ¥è¯†åŠ©æ‰‹ã€æ–‡æ¡£åˆ†æã€å®¢æœæœºå™¨äºº",
    "æŠ€æœ¯æŒ‘æˆ˜": "æ£€ç´¢è´¨é‡ã€ä¸Šä¸‹æ–‡é•¿åº¦ã€è®¡ç®—æ•ˆç‡ã€ä¸€è‡´æ€§ä¿è¯"
}

for concept, description in core_concepts.items():
    print(f"â€¢ {concept}: {description}")
```

---

## 3.5.2 å‘é‡æ•°æ®åº“ä¸åµŒå…¥æŠ€æœ¯

### å‘é‡æ•°æ®åº“çš„æ ¸å¿ƒä½œç”¨

å‘é‡æ•°æ®åº“æ˜¯RAGç³»ç»Ÿçš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼Œè´Ÿè´£é«˜æ•ˆå­˜å‚¨å’Œæ£€ç´¢é«˜ç»´å‘é‡è¡¨ç¤ºçš„æ–‡æ¡£ã€‚

```python
class VectorDatabaseAnalyzer:
    def __init__(self):
        self.embedding_models = {
            'Word2Vec': {'ç»´åº¦': 300, 'è®­ç»ƒæ•°æ®': 'é€šç”¨æ–‡æœ¬', 'æ€§èƒ½': 0.7},
            'GloVe': {'ç»´åº¦': 300, 'è®­ç»ƒæ•°æ®': 'é€šç”¨æ–‡æœ¬', 'æ€§èƒ½': 0.72},
            'FastText': {'ç»´åº¦': 300, 'è®­ç»ƒæ•°æ®': 'é€šç”¨æ–‡æœ¬', 'æ€§èƒ½': 0.75},
            'BERT': {'ç»´åº¦': 768, 'è®­ç»ƒæ•°æ®': 'å¤§è§„æ¨¡é¢„è®­ç»ƒ', 'æ€§èƒ½': 0.85},
            'Sentence-BERT': {'ç»´åº¦': 768, 'è®­ç»ƒæ•°æ®': 'å¥å­å¯¹', 'æ€§èƒ½': 0.88},
            'OpenAI Ada': {'ç»´åº¦': 1536, 'è®­ç»ƒæ•°æ®': 'å¤šæ¨¡æ€', 'æ€§èƒ½': 0.92}
        }
        
    def demonstrate_embedding_evolution(self):
        """æ¼”ç¤ºåµŒå…¥æŠ€æœ¯çš„æ¼”è¿›"""
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('å‘é‡åµŒå…¥æŠ€æœ¯æ¼”è¿›åˆ†æ', fontsize=16, fontweight='bold')
        
        models = list(self.embedding_models.keys())
        dimensions = [self.embedding_models[m]['ç»´åº¦'] for m in models]
        performances = [self.embedding_models[m]['æ€§èƒ½'] for m in models]
        
        # ç»´åº¦æ¼”è¿›
        colors = plt.cm.viridis(np.linspace(0, 1, len(models)))
        bars1 = ax1.bar(models, dimensions, color=colors)
        ax1.set_ylabel('å‘é‡ç»´åº¦')
        ax1.set_title('åµŒå…¥æ¨¡å‹ç»´åº¦æ¼”è¿›', fontweight='bold')
        ax1.tick_params(axis='x', rotation=45)
        
        for bar, dim in zip(bars1, dimensions):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + 10,
                    f'{dim}', ha='center', va='bottom', fontweight='bold')
        
        # æ€§èƒ½æå‡
        ax2.plot(models, performances, 'ro-', linewidth=3, markersize=8)
        ax2.set_ylabel('æ€§èƒ½è¯„åˆ†')
        ax2.set_title('åµŒå…¥æ¨¡å‹æ€§èƒ½æ¼”è¿›', fontweight='bold')
        ax2.tick_params(axis='x', rotation=45)
        ax2.grid(True, alpha=0.3)
        ax2.set_ylim(0.6, 1.0)
        
        for i, (model, perf) in enumerate(zip(models, performances)):
            ax2.annotate(f'{perf:.2f}', (i, perf), 
                        xytext=(0, 10), textcoords='offset points',
                        ha='center', fontweight='bold')
        
        # ç»´åº¦vsæ€§èƒ½æ•£ç‚¹å›¾
        scatter = ax3.scatter(dimensions, performances, s=200, 
                            c=range(len(models)), cmap='plasma', alpha=0.7)
        
        for i, model in enumerate(models):
            ax3.annotate(model, (dimensions[i], performances[i]), 
                        xytext=(5, 5), textcoords='offset points', fontsize=9)
        
        ax3.set_xlabel('å‘é‡ç»´åº¦')
        ax3.set_ylabel('æ€§èƒ½è¯„åˆ†')
        ax3.set_title('ç»´åº¦-æ€§èƒ½å…³ç³»åˆ†æ', fontweight='bold')
        ax3.grid(True, alpha=0.3)
        
        # æŠ€æœ¯ç‰¹ç‚¹é›·è¾¾å›¾
        features = ['è¯­ä¹‰ç†è§£', 'è®¡ç®—æ•ˆç‡', 'å­˜å‚¨æ•ˆç‡', 'è®­ç»ƒå¤æ‚åº¦', 'é€‚ç”¨æ€§']
        model_features = {
            'Word2Vec': [0.6, 0.8, 0.9, 0.7, 0.8],
            'BERT': [0.9, 0.4, 0.3, 0.3, 0.9],
            'Sentence-BERT': [0.95, 0.6, 0.4, 0.4, 0.95],
            'OpenAI Ada': [0.98, 0.5, 0.2, 0.2, 0.98]
        }
        
        angles = np.linspace(0, 2 * np.pi, len(features), endpoint=False).tolist()
        angles += angles[:1]
        
        ax4 = plt.subplot(224, projection='polar')
        
        colors = ['red', 'blue', 'green', 'orange']
        for i, (model, values) in enumerate(model_features.items()):
            values += values[:1]
            ax4.plot(angles, values, 'o-', linewidth=2, 
                    label=model, color=colors[i])
            ax4.fill(angles, values, alpha=0.1, color=colors[i])
        
        ax4.set_xticks(angles[:-1])
        ax4.set_xticklabels(features)
        ax4.set_ylim(0, 1)
        ax4.set_title('åµŒå…¥æ¨¡å‹ç‰¹å¾å¯¹æ¯”', fontweight='bold', pad=20)
        ax4.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))
        ax4.grid(True)
        
        plt.tight_layout()
        plt.show()
    
    def analyze_vector_databases(self):
        """åˆ†æå‘é‡æ•°æ®åº“ç‰¹æ€§"""
        vector_dbs = {
            'Faiss': {
                'ç±»å‹': 'Facebookå¼€æº',
                'æ€§èƒ½': 0.95,
                'æ˜“ç”¨æ€§': 0.7,
                'æ‰©å±•æ€§': 0.8,
                'åŠŸèƒ½': 0.85,
                'ç‰¹ç‚¹': 'é«˜æ€§èƒ½ã€å¤šç§ç´¢å¼•ç®—æ³•'
            },
            'Pinecone': {
                'ç±»å‹': 'äº‘æœåŠ¡',
                'æ€§èƒ½': 0.9,
                'æ˜“ç”¨æ€§': 0.95,
                'æ‰©å±•æ€§': 0.95,
                'åŠŸèƒ½': 0.9,
                'ç‰¹ç‚¹': 'æ‰˜ç®¡æœåŠ¡ã€è‡ªåŠ¨æ‰©å±•'
            },
            'Weaviate': {
                'ç±»å‹': 'å¼€æºå›¾æ•°æ®åº“',
                'æ€§èƒ½': 0.85,
                'æ˜“ç”¨æ€§': 0.8,
                'æ‰©å±•æ€§': 0.85,
                'åŠŸèƒ½': 0.95,
                'ç‰¹ç‚¹': 'å›¾ç»“æ„ã€å¤šæ¨¡æ€æ”¯æŒ'
            },
            'Milvus': {
                'ç±»å‹': 'å¼€æºåˆ†å¸ƒå¼',
                'æ€§èƒ½': 0.9,
                'æ˜“ç”¨æ€§': 0.75,
                'æ‰©å±•æ€§': 0.9,
                'åŠŸèƒ½': 0.88,
                'ç‰¹ç‚¹': 'åˆ†å¸ƒå¼ã€é«˜å¹¶å‘'
            },
            'Chroma': {
                'ç±»å‹': 'è½»é‡çº§å¼€æº',
                'æ€§èƒ½': 0.8,
                'æ˜“ç”¨æ€§': 0.9,
                'æ‰©å±•æ€§': 0.7,
                'åŠŸèƒ½': 0.8,
                'ç‰¹ç‚¹': 'ç®€å•æ˜“ç”¨ã€å¿«é€Ÿéƒ¨ç½²'
            }
        }
        
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('å‘é‡æ•°æ®åº“å¯¹æ¯”åˆ†æ', fontsize=16, fontweight='bold')
        
        # ç»¼åˆè¯„åˆ†å¯¹æ¯”
        dbs = list(vector_dbs.keys())
        metrics = ['æ€§èƒ½', 'æ˜“ç”¨æ€§', 'æ‰©å±•æ€§', 'åŠŸèƒ½']
        
        # è®¡ç®—ç»¼åˆè¯„åˆ†
        overall_scores = []
        for db in dbs:
            score = sum(vector_dbs[db][metric] for metric in metrics) / len(metrics)
            overall_scores.append(score)
        
        bars = ax1.bar(dbs, overall_scores, 
                      color=plt.cm.coolwarm(np.array(overall_scores)))
        ax1.set_ylabel('ç»¼åˆè¯„åˆ†')
        ax1.set_title('å‘é‡æ•°æ®åº“ç»¼åˆè¯„åˆ†', fontweight='bold')
        ax1.tick_params(axis='x', rotation=45)
        ax1.set_ylim(0, 1)
        
        for bar, score in zip(bars, overall_scores):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                    f'{score:.2f}', ha='center', va='bottom', fontweight='bold')
        
        # æ€§èƒ½çŸ©é˜µçƒ­åŠ›å›¾
        performance_matrix = np.array([
            [vector_dbs[db][metric] for metric in metrics] for db in dbs
        ])
        
        im = ax2.imshow(performance_matrix, cmap='RdYlGn', aspect='auto')
        ax2.set_xticks(range(len(metrics)))
        ax2.set_xticklabels(metrics)
        ax2.set_yticks(range(len(dbs)))
        ax2.set_yticklabels(dbs)
        ax2.set_title('æ€§èƒ½æŒ‡æ ‡çƒ­åŠ›å›¾', fontweight='bold')
        
        # æ·»åŠ æ•°å€¼æ ‡ç­¾
        for i in range(len(dbs)):
            for j in range(len(metrics)):
                text = ax2.text(j, i, f'{performance_matrix[i, j]:.2f}',
                               ha="center", va="center", color="black", fontweight='bold')
        
        # é¢œè‰²æ¡
        cbar = plt.colorbar(im, ax=ax2, shrink=0.8)
        cbar.set_label('è¯„åˆ†', rotation=270, labelpad=15)
        
        # ä½¿ç”¨åœºæ™¯åˆ†å¸ƒ
        use_cases = {
            'åŸå‹å¼€å‘': ['Chroma', 'Faiss'],
            'ç”Ÿäº§ç¯å¢ƒ': ['Pinecone', 'Milvus'],
            'ä¼ä¸šçº§': ['Weaviate', 'Milvus'],
            'ç ”ç©¶å®éªŒ': ['Faiss', 'Chroma'],
            'äº‘åŸç”Ÿ': ['Pinecone']
        }
        
        # ç»Ÿè®¡æ¯ä¸ªæ•°æ®åº“çš„ä½¿ç”¨åœºæ™¯æ•°é‡
        db_usage_count = {db: 0 for db in dbs}
        for scenarios in use_cases.values():
            for db in scenarios:
                if db in db_usage_count:
                    db_usage_count[db] += 1
        
        usage_dbs = list(db_usage_count.keys())
        usage_counts = list(db_usage_count.values())
        
        wedges, texts, autotexts = ax3.pie(usage_counts, labels=usage_dbs, 
                                          autopct='%1.1f%%', startangle=90,
                                          colors=plt.cm.Set3(np.linspace(0, 1, len(usage_dbs))))
        ax3.set_title('ä½¿ç”¨åœºæ™¯é€‚ç”¨æ€§åˆ†å¸ƒ', fontweight='bold')
        
        # é€‰æ‹©å†³ç­–çŸ©é˜µ
        decision_factors = {
            'æ•°æ®è§„æ¨¡': {'å°': 'Chroma', 'ä¸­': 'Faiss', 'å¤§': 'Milvus/Pinecone'},
            'æŠ€æœ¯å›¢é˜Ÿ': {'åˆçº§': 'Pinecone', 'ä¸­çº§': 'Chroma', 'é«˜çº§': 'Faiss/Milvus'},
            'é¢„ç®—': {'ä½': 'Faiss/Chroma', 'ä¸­': 'Milvus', 'é«˜': 'Pinecone'},
            'ç»´æŠ¤': {'æ‰˜ç®¡': 'Pinecone', 'è‡ªç»´æŠ¤': 'Faiss/Milvus/Chroma'}
        }
        
        ax4.axis('off')
        ax4.set_title('é€‰æ‹©å†³ç­–æŒ‡å—', fontweight='bold')
        
        y_pos = 0.9
        for factor, options in decision_factors.items():
            ax4.text(0.1, y_pos, f"{factor}:", fontweight='bold', fontsize=12)
            y_pos -= 0.1
            for level, recommendation in options.items():
                ax4.text(0.15, y_pos, f"â€¢ {level}: {recommendation}", fontsize=10)
                y_pos -= 0.08
            y_pos -= 0.05
        
        plt.tight_layout()
        plt.show()
    
    def demonstrate_similarity_search(self):
        """æ¼”ç¤ºç›¸ä¼¼åº¦æœç´¢ç®—æ³•"""
        # æ¨¡æ‹Ÿå‘é‡æ•°æ®
        np.random.seed(42)
        n_docs = 1000
        n_dims = 128
        
        # ç”Ÿæˆæ–‡æ¡£å‘é‡
        doc_vectors = np.random.randn(n_docs, n_dims)
        doc_vectors = doc_vectors / np.linalg.norm(doc_vectors, axis=1, keepdims=True)
        
        # æŸ¥è¯¢å‘é‡
        query_vector = np.random.randn(1, n_dims)
        query_vector = query_vector / np.linalg.norm(query_vector)
        
        # è®¡ç®—ç›¸ä¼¼åº¦
        similarities = cosine_similarity(query_vector, doc_vectors)[0]
        
        # ä¸åŒæœç´¢ç®—æ³•çš„æ€§èƒ½æ¨¡æ‹Ÿ
        search_algorithms = {
            'çº¿æ€§æœç´¢': {'æ—¶é—´å¤æ‚åº¦': 'O(n)', 'å‡†ç¡®ç‡': 1.0, 'é€Ÿåº¦': 0.3},
            'LSH': {'æ—¶é—´å¤æ‚åº¦': 'O(log n)', 'å‡†ç¡®ç‡': 0.85, 'é€Ÿåº¦': 0.8},
            'IVF': {'æ—¶é—´å¤æ‚åº¦': 'O(âˆšn)', 'å‡†ç¡®ç‡': 0.92, 'é€Ÿåº¦': 0.7},
            'HNSW': {'æ—¶é—´å¤æ‚åº¦': 'O(log n)', 'å‡†ç¡®ç‡': 0.95, 'é€Ÿåº¦': 0.9},
            'Annoy': {'æ—¶é—´å¤æ‚åº¦': 'O(log n)', 'å‡†ç¡®ç‡': 0.88, 'é€Ÿåº¦': 0.85}
        }
        
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('ç›¸ä¼¼åº¦æœç´¢ç®—æ³•åˆ†æ', fontsize=16, fontweight='bold')
        
        # ç›¸ä¼¼åº¦åˆ†å¸ƒ
        ax1.hist(similarities, bins=50, alpha=0.7, color='skyblue', edgecolor='black')
        ax1.axvline(np.mean(similarities), color='red', linestyle='--', 
                   linewidth=2, label=f'å¹³å‡å€¼: {np.mean(similarities):.3f}')
        ax1.axvline(np.percentile(similarities, 95), color='green', linestyle='--', 
                   linewidth=2, label=f'95%åˆ†ä½: {np.percentile(similarities, 95):.3f}')
        ax1.set_xlabel('ä½™å¼¦ç›¸ä¼¼åº¦')
        ax1.set_ylabel('æ–‡æ¡£æ•°é‡')
        ax1.set_title('æ–‡æ¡£ç›¸ä¼¼åº¦åˆ†å¸ƒ', fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # ç®—æ³•æ€§èƒ½å¯¹æ¯”
        algorithms = list(search_algorithms.keys())
        accuracies = [search_algorithms[alg]['å‡†ç¡®ç‡'] for alg in algorithms]
        speeds = [search_algorithms[alg]['é€Ÿåº¦'] for alg in algorithms]
        
        scatter = ax2.scatter(speeds, accuracies, s=200, 
                            c=range(len(algorithms)), cmap='viridis', alpha=0.7)
        
        for i, alg in enumerate(algorithms):
            ax2.annotate(alg, (speeds[i], accuracies[i]), 
                        xytext=(5, 5), textcoords='offset points', fontsize=9)
        
        ax2.set_xlabel('æœç´¢é€Ÿåº¦')
        ax2.set_ylabel('å‡†ç¡®ç‡')
        ax2.set_title('ç®—æ³•æ€§èƒ½æƒè¡¡åˆ†æ', fontweight='bold')
        ax2.grid(True, alpha=0.3)
        ax2.set_xlim(0, 1)
        ax2.set_ylim(0.8, 1.0)
        
        # Top-Kæ£€ç´¢ç»“æœ
        top_k = 10
        top_indices = np.argsort(similarities)[-top_k:][::-1]
        top_similarities = similarities[top_indices]
        
        bars = ax3.bar(range(top_k), top_similarities, 
                      color=plt.cm.plasma(top_similarities))
        ax3.set_xlabel('æ’å')
        ax3.set_ylabel('ç›¸ä¼¼åº¦')
        ax3.set_title(f'Top-{top_k} æ£€ç´¢ç»“æœ', fontweight='bold')
        ax3.set_xticks(range(top_k))
        ax3.set_xticklabels([f'#{i+1}' for i in range(top_k)])
        
        for bar, sim in zip(bars, top_similarities):
            height = bar.get_height()
            ax3.text(bar.get_x() + bar.get_width()/2., height + 0.005,
                    f'{sim:.3f}', ha='center', va='bottom', fontsize=9)
        
        # æœç´¢æ•ˆç‡vsæ•°æ®è§„æ¨¡
        data_sizes = [1000, 10000, 100000, 1000000, 10000000]
        
        # æ¨¡æ‹Ÿä¸åŒç®—æ³•çš„æœç´¢æ—¶é—´ï¼ˆç›¸å¯¹å€¼ï¼‰
        linear_times = [size/1000 for size in data_sizes]
        hnsw_times = [np.log2(size/1000) for size in data_sizes]
        ivf_times = [np.sqrt(size/1000) for size in data_sizes]
        
        ax4.loglog(data_sizes, linear_times, 'r-o', label='çº¿æ€§æœç´¢', linewidth=2)
        ax4.loglog(data_sizes, hnsw_times, 'b-s', label='HNSW', linewidth=2)
        ax4.loglog(data_sizes, ivf_times, 'g-^', label='IVF', linewidth=2)
        
        ax4.set_xlabel('æ•°æ®è§„æ¨¡')
        ax4.set_ylabel('æœç´¢æ—¶é—´(ç›¸å¯¹å€¼)')
        ax4.set_title('æœç´¢æ•ˆç‡vsæ•°æ®è§„æ¨¡', fontweight='bold')
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()

# æ¼”ç¤ºå‘é‡æ•°æ®åº“åˆ†æ
vdb_analyzer = VectorDatabaseAnalyzer()
vdb_analyzer.demonstrate_embedding_evolution()
vdb_analyzer.analyze_vector_databases()
vdb_analyzer.demonstrate_similarity_search()

print("\n=== å‘é‡æ•°æ®åº“æ ¸å¿ƒè¦ç‚¹ ===")
vector_db_concepts = {
    "åµŒå…¥æŠ€æœ¯": "å°†æ–‡æœ¬è½¬æ¢ä¸ºé«˜ç»´å‘é‡çš„æ ¸å¿ƒæŠ€æœ¯",
    "ç›¸ä¼¼åº¦è®¡ç®—": "ä½™å¼¦ç›¸ä¼¼åº¦ã€æ¬§æ°è·ç¦»ã€ç‚¹ç§¯ç­‰åº¦é‡æ–¹æ³•",
    "ç´¢å¼•ç®—æ³•": "HNSWã€IVFã€LSHç­‰é«˜æ•ˆæ£€ç´¢ç®—æ³•",
    "å­˜å‚¨ä¼˜åŒ–": "å‘é‡å‹ç¼©ã€åˆ†ç‰‡å­˜å‚¨ã€ç¼“å­˜ç­–ç•¥",
    "æ€§èƒ½è°ƒä¼˜": "ç´¢å¼•å‚æ•°ã€æ‰¹å¤„ç†ã€å¹¶è¡Œè®¡ç®—"
}

for concept, description in vector_db_concepts.items():
    print(f"â€¢ {concept}: {description}")
```

---

## æœ¬èŠ‚å°ç»“

é€šè¿‡æœ¬èŠ‚çš„å­¦ä¹ ï¼Œæˆ‘ä»¬æ·±å…¥äº†è§£äº†RAGæŠ€æœ¯çš„æ ¸å¿ƒåŸç†å’Œå®ç°æ–¹æ³•ï¼š

### ğŸ¯ æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **RAGæ¶æ„**: ç†è§£æ£€ç´¢-ç”Ÿæˆæ··åˆæ¶æ„çš„è®¾è®¡åŸç†
2. **å·¥ä½œæµç¨‹**: æŒæ¡ä»æŸ¥è¯¢åˆ°ç­”æ¡ˆç”Ÿæˆçš„å®Œæ•´æµç¨‹
3. **æ£€ç´¢æ–¹æ³•**: å­¦ä¹ ä¸åŒæ£€ç´¢ç­–ç•¥çš„ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯
4. **å‘é‡æ•°æ®åº“**: äº†è§£åµŒå…¥æŠ€æœ¯å’Œå‘é‡å­˜å‚¨çš„æ ¸å¿ƒæŠ€æœ¯
5. **ç›¸ä¼¼åº¦æœç´¢**: æŒæ¡é«˜æ•ˆçš„å‘é‡æ£€ç´¢ç®—æ³•

### ğŸ› ï¸ Traeå®è·µè¦ç‚¹

- **æ¶æ„è®¾è®¡**: æ ¹æ®åº”ç”¨éœ€æ±‚é€‰æ‹©åˆé€‚çš„RAGæ¶æ„
- **æ•°æ®å‡†å¤‡**: é‡è§†çŸ¥è¯†åº“çš„æ„å»ºå’Œå‘é‡åŒ–è´¨é‡
- **æ£€ç´¢ä¼˜åŒ–**: å¹³è¡¡æ£€ç´¢ç²¾åº¦å’Œæ•ˆç‡
- **ç³»ç»Ÿé›†æˆ**: ç¡®ä¿å„ç»„ä»¶çš„åè°ƒå·¥ä½œ

### ğŸ¤” æ·±åº¦æ€è€ƒé¢˜

1. å¦‚ä½•è¯„ä¼°RAGç³»ç»Ÿçš„æ£€ç´¢è´¨é‡ï¼Ÿ
2. å‘é‡æ•°æ®åº“çš„é€‰æ‹©æ ‡å‡†æ˜¯ä»€ä¹ˆï¼Ÿ
3. å¦‚ä½•å¤„ç†æ£€ç´¢ç»“æœä¸ç”Ÿæˆå†…å®¹çš„ä¸€è‡´æ€§ï¼Ÿ

---

## 3.5.3 æ£€ç´¢ç­–ç•¥ä¼˜åŒ–ä¸é«˜çº§æŠ€æœ¯

### å¤šé˜¶æ®µæ£€ç´¢ç­–ç•¥

ç°ä»£RAGç³»ç»Ÿé‡‡ç”¨å¤šé˜¶æ®µæ£€ç´¢æ¥æé«˜æ£€ç´¢è´¨é‡å’Œæ•ˆç‡ã€‚

```python
class AdvancedRetrievalAnalyzer:
    def __init__(self):
        self.retrieval_stages = {
            'ç²—æ£€ç´¢': {'å¬å›æ•°é‡': 1000, 'ç²¾åº¦': 0.7, 'é€Ÿåº¦': 0.95},
            'ç²¾æ£€ç´¢': {'å¬å›æ•°é‡': 100, 'ç²¾åº¦': 0.85, 'é€Ÿåº¦': 0.7},
            'é‡æ’åº': {'å¬å›æ•°é‡': 10, 'ç²¾åº¦': 0.95, 'é€Ÿåº¦': 0.5}
        }
        
    def demonstrate_multi_stage_retrieval(self):
        """æ¼”ç¤ºå¤šé˜¶æ®µæ£€ç´¢æµç¨‹"""
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('å¤šé˜¶æ®µæ£€ç´¢ç­–ç•¥åˆ†æ', fontsize=16, fontweight='bold')
        
        # æ£€ç´¢æ¼æ–—å›¾
        stages = list(self.retrieval_stages.keys())
        recalls = [self.retrieval_stages[stage]['å¬å›æ•°é‡'] for stage in stages]
        precisions = [self.retrieval_stages[stage]['ç²¾åº¦'] for stage in stages]
        
        # æ¼æ–—å›¾
        y_positions = np.arange(len(stages))
        colors = ['lightcoral', 'lightblue', 'lightgreen']
        
        for i, (stage, recall, color) in enumerate(zip(stages, recalls, colors)):
            width = recall / max(recalls) * 0.8  # å½’ä¸€åŒ–å®½åº¦
            rect = Rectangle((0.5 - width/2, i - 0.3), width, 0.6, 
                           facecolor=color, edgecolor='black', alpha=0.7)
            ax1.add_patch(rect)
            ax1.text(0.5, i, f'{stage}\n{recall}ä¸ªæ–‡æ¡£', 
                    ha='center', va='center', fontweight='bold')
        
        ax1.set_xlim(0, 1)
        ax1.set_ylim(-0.5, len(stages) - 0.5)
        ax1.set_yticks(y_positions)
        ax1.set_yticklabels(stages)
        ax1.set_title('æ£€ç´¢æ¼æ–—æµç¨‹', fontweight='bold')
        ax1.axis('off')
        
        # ç²¾åº¦æå‡æ›²çº¿
        ax2.plot(stages, precisions, 'ro-', linewidth=3, markersize=10)
        ax2.set_ylabel('æ£€ç´¢ç²¾åº¦')
        ax2.set_title('å„é˜¶æ®µç²¾åº¦æå‡', fontweight='bold')
        ax2.grid(True, alpha=0.3)
        ax2.set_ylim(0.6, 1.0)
        
        for i, (stage, precision) in enumerate(zip(stages, precisions)):
            ax2.annotate(f'{precision:.2f}', (i, precision), 
                        xytext=(0, 10), textcoords='offset points',
                        ha='center', fontweight='bold')
        
        # æˆæœ¬æ•ˆç›Šåˆ†æ
        speeds = [self.retrieval_stages[stage]['é€Ÿåº¦'] for stage in stages]
        
        # è®¡ç®—ç´¯ç§¯æˆæœ¬ï¼ˆ1-é€Ÿåº¦ï¼‰å’Œç´¯ç§¯æ”¶ç›Šï¼ˆç²¾åº¦æå‡ï¼‰
        cumulative_cost = np.cumsum([1-s for s in speeds])
        cumulative_benefit = np.array(precisions)
        
        ax3.plot(cumulative_cost, cumulative_benefit, 'bs-', linewidth=2, markersize=8)
        
        for i, stage in enumerate(stages):
            ax3.annotate(stage, (cumulative_cost[i], cumulative_benefit[i]), 
                        xytext=(5, 5), textcoords='offset points', fontsize=9)
        
        ax3.set_xlabel('ç´¯ç§¯è®¡ç®—æˆæœ¬')
        ax3.set_ylabel('æ£€ç´¢ç²¾åº¦')
        ax3.set_title('æˆæœ¬-æ•ˆç›Šæƒè¡¡åˆ†æ', fontweight='bold')
        ax3.grid(True, alpha=0.3)
        
        # æ£€ç´¢ç­–ç•¥å¯¹æ¯”
        strategies = {
            'å•é˜¶æ®µæ£€ç´¢': {'ç²¾åº¦': 0.75, 'é€Ÿåº¦': 0.8, 'å¤æ‚åº¦': 0.3},
            'ä¸¤é˜¶æ®µæ£€ç´¢': {'ç²¾åº¦': 0.88, 'é€Ÿåº¦': 0.65, 'å¤æ‚åº¦': 0.6},
            'ä¸‰é˜¶æ®µæ£€ç´¢': {'ç²¾åº¦': 0.95, 'é€Ÿåº¦': 0.5, 'å¤æ‚åº¦': 0.9}
        }
        
        strategy_names = list(strategies.keys())
        metrics = ['ç²¾åº¦', 'é€Ÿåº¦', 'å¤æ‚åº¦']
        
        angles = np.linspace(0, 2 * np.pi, len(metrics), endpoint=False).tolist()
        angles += angles[:1]
        
        ax4 = plt.subplot(224, projection='polar')
        
        colors = ['red', 'blue', 'green']
        for i, (strategy, values_dict) in enumerate(strategies.items()):
            values = [values_dict[metric] for metric in metrics]
            values += values[:1]
            
            ax4.plot(angles, values, 'o-', linewidth=2, 
                    label=strategy, color=colors[i])
            ax4.fill(angles, values, alpha=0.1, color=colors[i])
        
        ax4.set_xticks(angles[:-1])
        ax4.set_xticklabels(metrics)
        ax4.set_ylim(0, 1)
        ax4.set_title('æ£€ç´¢ç­–ç•¥ç»¼åˆå¯¹æ¯”', fontweight='bold', pad=20)
        ax4.legend(loc='upper right', bbox_to_anchor=(0.1, 0.1))
        ax4.grid(True)
        
        plt.tight_layout()
        plt.show()
    
    def analyze_query_expansion(self):
        """åˆ†ææŸ¥è¯¢æ‰©å±•æŠ€æœ¯"""
        expansion_methods = {
            'åŒä¹‰è¯æ‰©å±•': {
                'åŸç†': 'åŸºäºè¯å…¸çš„åŒä¹‰è¯æ›¿æ¢',
                'æ•ˆæœ': 0.15,
                'å¤æ‚åº¦': 0.2,
                'é€‚ç”¨åœºæ™¯': 'é€šç”¨æŸ¥è¯¢'
            },
            'è¯åµŒå…¥æ‰©å±•': {
                'åŸç†': 'åŸºäºè¯å‘é‡çš„è¯­ä¹‰ç›¸ä¼¼è¯',
                'æ•ˆæœ': 0.25,
                'å¤æ‚åº¦': 0.5,
                'é€‚ç”¨åœºæ™¯': 'è¯­ä¹‰æŸ¥è¯¢'
            },
            'ä¼ªç›¸å…³åé¦ˆ': {
                'åŸç†': 'åˆ©ç”¨åˆå§‹æ£€ç´¢ç»“æœæ‰©å±•æŸ¥è¯¢',
                'æ•ˆæœ': 0.35,
                'å¤æ‚åº¦': 0.7,
                'é€‚ç”¨åœºæ™¯': 'è¿­ä»£æ£€ç´¢'
            },
            'LLMæŸ¥è¯¢é‡å†™': {
                'åŸç†': 'ä½¿ç”¨è¯­è¨€æ¨¡å‹é‡å†™å’Œæ‰©å±•æŸ¥è¯¢',
                'æ•ˆæœ': 0.45,
                'å¤æ‚åº¦': 0.9,
                'é€‚ç”¨åœºæ™¯': 'å¤æ‚æŸ¥è¯¢'
            }
        }
        
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('æŸ¥è¯¢æ‰©å±•æŠ€æœ¯åˆ†æ', fontsize=16, fontweight='bold')
        
        methods = list(expansion_methods.keys())
        effects = [expansion_methods[m]['æ•ˆæœ'] for m in methods]
        complexities = [expansion_methods[m]['å¤æ‚åº¦'] for m in methods]
        
        # æ•ˆæœå¯¹æ¯”
        bars = ax1.bar(methods, effects, color=plt.cm.viridis(np.array(effects)))
        ax1.set_ylabel('æ€§èƒ½æå‡')
        ax1.set_title('æŸ¥è¯¢æ‰©å±•æ•ˆæœå¯¹æ¯”', fontweight='bold')
        ax1.tick_params(axis='x', rotation=45)
        
        for bar, effect in zip(bars, effects):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                    f'{effect:.2f}', ha='center', va='bottom', fontweight='bold')
        
        # æ•ˆæœvså¤æ‚åº¦æ•£ç‚¹å›¾
        scatter = ax2.scatter(complexities, effects, s=200, 
                            c=range(len(methods)), cmap='plasma', alpha=0.7)
        
        for i, method in enumerate(methods):
            ax2.annotate(method, (complexities[i], effects[i]), 
                        xytext=(5, 5), textcoords='offset points', fontsize=9)
        
        ax2.set_xlabel('å®ç°å¤æ‚åº¦')
        ax2.set_ylabel('æ€§èƒ½æå‡')
        ax2.set_title('æ•ˆæœ-å¤æ‚åº¦æƒè¡¡', fontweight='bold')
        ax2.grid(True, alpha=0.3)
        
        # æŸ¥è¯¢æ‰©å±•ç¤ºä¾‹
        query_examples = {
            'åŸå§‹æŸ¥è¯¢': 'Pythonæœºå™¨å­¦ä¹ ',
            'åŒä¹‰è¯æ‰©å±•': 'Pythonæœºå™¨å­¦ä¹  ML äººå·¥æ™ºèƒ½ ç®—æ³•',
            'è¯­ä¹‰æ‰©å±•': 'Pythonæœºå™¨å­¦ä¹  scikit-learn pandas numpy æ•°æ®ç§‘å­¦',
            'LLMé‡å†™': 'Pythonç¼–ç¨‹è¯­è¨€åœ¨æœºå™¨å­¦ä¹ å’Œäººå·¥æ™ºèƒ½é¢†åŸŸçš„åº”ç”¨ï¼ŒåŒ…æ‹¬ç›¸å…³åº“å’Œæ¡†æ¶'
        }
        
        ax3.axis('off')
        ax3.set_title('æŸ¥è¯¢æ‰©å±•ç¤ºä¾‹', fontweight='bold')
        
        y_pos = 0.9
        for query_type, query_text in query_examples.items():
            ax3.text(0.05, y_pos, f"{query_type}:", fontweight='bold', fontsize=11)
            y_pos -= 0.1
            # æ–‡æœ¬æ¢è¡Œå¤„ç†
            wrapped_text = '\n'.join([query_text[i:i+50] for i in range(0, len(query_text), 50)])
            ax3.text(0.1, y_pos, wrapped_text, fontsize=10, 
                    bbox=dict(boxstyle="round,pad=0.3", facecolor='lightgray'))
            y_pos -= 0.15
        
        # æ‰©å±•ç­–ç•¥é€‰æ‹©æŒ‡å—
        selection_guide = {
            'æŸ¥è¯¢é•¿åº¦': {'çŸ­æŸ¥è¯¢': 'LLMé‡å†™', 'ä¸­ç­‰æŸ¥è¯¢': 'è¯­ä¹‰æ‰©å±•', 'é•¿æŸ¥è¯¢': 'ä¼ªç›¸å…³åé¦ˆ'},
            'é¢†åŸŸç‰¹æ€§': {'é€šç”¨': 'åŒä¹‰è¯æ‰©å±•', 'ä¸“ä¸š': 'è¯åµŒå…¥æ‰©å±•', 'å¤æ‚': 'LLMé‡å†™'},
            'æ€§èƒ½è¦æ±‚': {'å®æ—¶': 'åŒä¹‰è¯æ‰©å±•', 'å‡†ç¡®': 'LLMé‡å†™', 'å¹³è¡¡': 'è¯­ä¹‰æ‰©å±•'}
        }
        
        ax4.axis('off')
        ax4.set_title('æ‰©å±•ç­–ç•¥é€‰æ‹©æŒ‡å—', fontweight='bold')
        
        y_pos = 0.9
        for factor, recommendations in selection_guide.items():
            ax4.text(0.05, y_pos, f"{factor}:", fontweight='bold', fontsize=11)
            y_pos -= 0.1
            for condition, method in recommendations.items():
                ax4.text(0.1, y_pos, f"â€¢ {condition}: {method}", fontsize=10)
                y_pos -= 0.08
            y_pos -= 0.05
        
        plt.tight_layout()
        plt.show()
    
    def demonstrate_hybrid_search(self):
        """æ¼”ç¤ºæ··åˆæœç´¢ç­–ç•¥"""
        # æ¨¡æ‹Ÿä¸åŒæœç´¢æ–¹æ³•çš„ç»“æœ
        np.random.seed(42)
        n_docs = 100
        
        # å…³é”®è¯æœç´¢ç»“æœï¼ˆç²¾ç¡®åŒ¹é…é«˜ï¼Œè¯­ä¹‰ç†è§£ä½ï¼‰
        keyword_scores = np.random.beta(2, 5, n_docs)  # åå‘ä½åˆ†
        keyword_scores[:10] = np.random.beta(5, 2, 10)  # å‰10ä¸ªé«˜åˆ†
        
        # å‘é‡æœç´¢ç»“æœï¼ˆè¯­ä¹‰ç†è§£é«˜ï¼Œç²¾ç¡®åŒ¹é…ä¸­ç­‰ï¼‰
        vector_scores = np.random.beta(3, 3, n_docs)  # å‡åŒ€åˆ†å¸ƒ
        
        # æ··åˆæœç´¢ç»“æœ
        alpha = 0.6  # å‘é‡æœç´¢æƒé‡
        hybrid_scores = alpha * vector_scores + (1 - alpha) * keyword_scores
        
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('æ··åˆæœç´¢ç­–ç•¥åˆ†æ', fontsize=16, fontweight='bold')
        
        # åˆ†æ•°åˆ†å¸ƒå¯¹æ¯”
        bins = np.linspace(0, 1, 20)
        
        ax1.hist(keyword_scores, bins=bins, alpha=0.5, label='å…³é”®è¯æœç´¢', 
                color='red', density=True)
        ax1.hist(vector_scores, bins=bins, alpha=0.5, label='å‘é‡æœç´¢', 
                color='blue', density=True)
        ax1.hist(hybrid_scores, bins=bins, alpha=0.5, label='æ··åˆæœç´¢', 
                color='green', density=True)
        
        ax1.set_xlabel('ç›¸å…³æ€§åˆ†æ•°')
        ax1.set_ylabel('å¯†åº¦')
        ax1.set_title('ä¸åŒæœç´¢æ–¹æ³•åˆ†æ•°åˆ†å¸ƒ', fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # Top-Kç»“æœå¯¹æ¯”
        k = 10
        top_k_keyword = np.argsort(keyword_scores)[-k:][::-1]
        top_k_vector = np.argsort(vector_scores)[-k:][::-1]
        top_k_hybrid = np.argsort(hybrid_scores)[-k:][::-1]
        
        x = np.arange(k)
        width = 0.25
        
        bars1 = ax2.bar(x - width, keyword_scores[top_k_keyword], width, 
                       label='å…³é”®è¯', color='red', alpha=0.7)
        bars2 = ax2.bar(x, vector_scores[top_k_vector], width, 
                       label='å‘é‡', color='blue', alpha=0.7)
        bars3 = ax2.bar(x + width, hybrid_scores[top_k_hybrid], width, 
                       label='æ··åˆ', color='green', alpha=0.7)
        
        ax2.set_xlabel('æ’å')
        ax2.set_ylabel('ç›¸å…³æ€§åˆ†æ•°')
        ax2.set_title(f'Top-{k} ç»“æœè´¨é‡å¯¹æ¯”', fontweight='bold')
        ax2.set_xticks(x)
        ax2.set_xticklabels([f'#{i+1}' for i in range(k)])
        ax2.legend()
        
        # æƒé‡è°ƒä¼˜åˆ†æ
        alphas = np.linspace(0, 1, 21)
        precision_scores = []
        recall_scores = []
        
        # æ¨¡æ‹ŸçœŸå®ç›¸å…³æ–‡æ¡£ï¼ˆå‰20ä¸ªï¼‰
        relevant_docs = set(range(20))
        
        for alpha in alphas:
            hybrid = alpha * vector_scores + (1 - alpha) * keyword_scores
            top_10 = set(np.argsort(hybrid)[-10:])
            
            precision = len(top_10 & relevant_docs) / len(top_10)
            recall = len(top_10 & relevant_docs) / len(relevant_docs)
            
            precision_scores.append(precision)
            recall_scores.append(recall)
        
        ax3.plot(alphas, precision_scores, 'r-o', label='ç²¾ç¡®ç‡', linewidth=2)
        ax3.plot(alphas, recall_scores, 'b-s', label='å¬å›ç‡', linewidth=2)
        
        # æ‰¾åˆ°æœ€ä¼˜æƒé‡
        f1_scores = [2 * p * r / (p + r) if (p + r) > 0 else 0 
                    for p, r in zip(precision_scores, recall_scores)]
        best_alpha_idx = np.argmax(f1_scores)
        best_alpha = alphas[best_alpha_idx]
        
        ax3.axvline(best_alpha, color='green', linestyle='--', 
                   label=f'æœ€ä¼˜æƒé‡: {best_alpha:.2f}')
        
        ax3.set_xlabel('å‘é‡æœç´¢æƒé‡ (Î±)')
        ax3.set_ylabel('è¯„ä¼°æŒ‡æ ‡')
        ax3.set_title('æ··åˆæœç´¢æƒé‡è°ƒä¼˜', fontweight='bold')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # æœç´¢ç­–ç•¥é€‚ç”¨åœºæ™¯
        scenarios = {
            'ç²¾ç¡®åŒ¹é…': {'å…³é”®è¯': 0.9, 'å‘é‡': 0.6, 'æ··åˆ': 0.85},
            'è¯­ä¹‰ç†è§£': {'å…³é”®è¯': 0.4, 'å‘é‡': 0.95, 'æ··åˆ': 0.8},
            'å¤šè¯­è¨€': {'å…³é”®è¯': 0.3, 'å‘é‡': 0.8, 'æ··åˆ': 0.7},
            'é•¿æ–‡æ¡£': {'å…³é”®è¯': 0.6, 'å‘é‡': 0.85, 'æ··åˆ': 0.9},
            'å®æ—¶æ€§': {'å…³é”®è¯': 0.95, 'å‘é‡': 0.7, 'æ··åˆ': 0.75}
        }
        
        scenario_names = list(scenarios.keys())
        search_methods = ['å…³é”®è¯', 'å‘é‡', 'æ··åˆ']
        
        # åˆ›å»ºçƒ­åŠ›å›¾æ•°æ®
        heatmap_data = np.array([
            [scenarios[scenario][method] for method in search_methods]
            for scenario in scenario_names
        ])
        
        im = ax4.imshow(heatmap_data, cmap='RdYlGn', aspect='auto')
        ax4.set_xticks(range(len(search_methods)))
        ax4.set_xticklabels(search_methods)
        ax4.set_yticks(range(len(scenario_names)))
        ax4.set_yticklabels(scenario_names)
        ax4.set_title('ä¸åŒåœºæ™¯é€‚ç”¨æ€§çƒ­åŠ›å›¾', fontweight='bold')
        
        # æ·»åŠ æ•°å€¼æ ‡ç­¾
        for i in range(len(scenario_names)):
            for j in range(len(search_methods)):
                text = ax4.text(j, i, f'{heatmap_data[i, j]:.2f}',
                               ha="center", va="center", color="black", fontweight='bold')
        
        # é¢œè‰²æ¡
        cbar = plt.colorbar(im, ax=ax4, shrink=0.8)
        cbar.set_label('é€‚ç”¨æ€§è¯„åˆ†', rotation=270, labelpad=15)
        
        plt.tight_layout()
        plt.show()

# æ¼”ç¤ºé«˜çº§æ£€ç´¢æŠ€æœ¯
advanced_retrieval = AdvancedRetrievalAnalyzer()
advanced_retrieval.demonstrate_multi_stage_retrieval()
advanced_retrieval.analyze_query_expansion()
advanced_retrieval.demonstrate_hybrid_search()

print("\n=== é«˜çº§æ£€ç´¢ç­–ç•¥è¦ç‚¹ ===")
advanced_concepts = {
    "å¤šé˜¶æ®µæ£€ç´¢": "ç²—æ£€ç´¢â†’ç²¾æ£€ç´¢â†’é‡æ’åºçš„æ¸è¿›å¼ç­–ç•¥",
    "æŸ¥è¯¢æ‰©å±•": "é€šè¿‡åŒä¹‰è¯ã€è¯­ä¹‰è¯ã€LLMé‡å†™æ‰©å±•æŸ¥è¯¢",
    "æ··åˆæœç´¢": "ç»“åˆå…³é”®è¯å’Œå‘é‡æœç´¢çš„ä¼˜åŠ¿",
    "æƒé‡è°ƒä¼˜": "æ ¹æ®åº”ç”¨åœºæ™¯è°ƒæ•´ä¸åŒæœç´¢æ–¹æ³•çš„æƒé‡",
    "æ€§èƒ½ä¼˜åŒ–": "å¹³è¡¡æ£€ç´¢è´¨é‡å’Œè®¡ç®—æ•ˆç‡"
}

for concept, description in advanced_concepts.items():
    print(f"â€¢ {concept}: {description}")
```

---

## 3.5.4 RAGç³»ç»Ÿè¯„ä¼°ä¸ä¼˜åŒ–

### è¯„ä¼°æŒ‡æ ‡ä½“ç³»

RAGç³»ç»Ÿçš„è¯„ä¼°éœ€è¦ä»å¤šä¸ªç»´åº¦è¿›è¡Œç»¼åˆè€ƒé‡ã€‚

```python
class RAGEvaluationAnalyzer:
    def __init__(self):
        self.evaluation_metrics = {
            'æ£€ç´¢è´¨é‡': {
                'Hit Rate': 'æ£€ç´¢ç»“æœä¸­åŒ…å«ç›¸å…³æ–‡æ¡£çš„æ¯”ä¾‹',
                'MRR': 'å¹³å‡å€’æ•°æ’åï¼Œè¡¡é‡ç›¸å…³æ–‡æ¡£çš„æ’åè´¨é‡',
                'NDCG': 'å½’ä¸€åŒ–æŠ˜æ‰£ç´¯ç§¯å¢ç›Šï¼Œè€ƒè™‘æ’åå’Œç›¸å…³æ€§',
                'Precision@K': 'å‰Kä¸ªç»“æœä¸­ç›¸å…³æ–‡æ¡£çš„æ¯”ä¾‹'
            },
            'ç”Ÿæˆè´¨é‡': {
                'BLEU': 'ä¸å‚è€ƒç­”æ¡ˆçš„n-gramé‡å åº¦',
                'ROUGE': 'å¬å›å¯¼å‘çš„æ–‡æœ¬ç›¸ä¼¼åº¦',
                'BERTScore': 'åŸºäºBERTçš„è¯­ä¹‰ç›¸ä¼¼åº¦',
                'Faithfulness': 'ç”Ÿæˆå†…å®¹å¯¹æ£€ç´¢æ–‡æ¡£çš„å¿ å®åº¦'
            },
            'ç³»ç»Ÿæ€§èƒ½': {
                'Latency': 'ç«¯åˆ°ç«¯å“åº”æ—¶é—´',
                'Throughput': 'å•ä½æ—¶é—´å¤„ç†çš„æŸ¥è¯¢æ•°é‡',
                'Memory Usage': 'ç³»ç»Ÿå†…å­˜å ç”¨',
                'Cost': 'è®¡ç®—å’Œå­˜å‚¨æˆæœ¬'
            }
        }
    
    def demonstrate_evaluation_framework(self):
        """æ¼”ç¤ºRAGè¯„ä¼°æ¡†æ¶"""
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('RAGç³»ç»Ÿè¯„ä¼°æ¡†æ¶', fontsize=16, fontweight='bold')
        
        # è¯„ä¼°ç»´åº¦æƒé‡åˆ†å¸ƒ
        dimensions = list(self.evaluation_metrics.keys())
        weights = [0.4, 0.4, 0.2]  # æ£€ç´¢è´¨é‡ã€ç”Ÿæˆè´¨é‡ã€ç³»ç»Ÿæ€§èƒ½çš„æƒé‡
        
        wedges, texts, autotexts = ax1.pie(weights, labels=dimensions, autopct='%1.1f%%',
                                          startangle=90, colors=['lightcoral', 'lightblue', 'lightgreen'])
        ax1.set_title('è¯„ä¼°ç»´åº¦æƒé‡åˆ†å¸ƒ', fontweight='bold')
        
        # ä¸åŒRAGç³»ç»Ÿçš„æ€§èƒ½å¯¹æ¯”
        rag_systems = {
            'Basic RAG': {'æ£€ç´¢è´¨é‡': 0.7, 'ç”Ÿæˆè´¨é‡': 0.75, 'ç³»ç»Ÿæ€§èƒ½': 0.9},
            'Advanced RAG': {'æ£€ç´¢è´¨é‡': 0.85, 'ç”Ÿæˆè´¨é‡': 0.82, 'ç³»ç»Ÿæ€§èƒ½': 0.75},
            'Optimized RAG': {'æ£€ç´¢è´¨é‡': 0.9, 'ç”Ÿæˆè´¨é‡': 0.88, 'ç³»ç»Ÿæ€§èƒ½': 0.8}
        }
        
        systems = list(rag_systems.keys())
        metrics = list(rag_systems['Basic RAG'].keys())
        
        x = np.arange(len(metrics))
        width = 0.25
        
        colors = ['red', 'blue', 'green']
        for i, (system, color) in enumerate(zip(systems, colors)):
            values = [rag_systems[system][metric] for metric in metrics]
            bars = ax2.bar(x + i * width, values, width, label=system, 
                          color=color, alpha=0.7)
            
            # æ·»åŠ æ•°å€¼æ ‡ç­¾
            for bar, value in zip(bars, values):
                height = bar.get_height()
                ax2.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                        f'{value:.2f}', ha='center', va='bottom', fontsize=9)
        
        ax2.set_xlabel('è¯„ä¼°ç»´åº¦')
        ax2.set_ylabel('è¯„åˆ†')
        ax2.set_title('ä¸åŒRAGç³»ç»Ÿæ€§èƒ½å¯¹æ¯”', fontweight='bold')
        ax2.set_xticks(x + width)
        ax2.set_xticklabels(metrics)
        ax2.legend()
        ax2.set_ylim(0, 1)
        
        # è¯„ä¼°æŒ‡æ ‡ç›¸å…³æ€§åˆ†æ
        np.random.seed(42)
        n_experiments = 50
        
        # æ¨¡æ‹Ÿä¸åŒæŒ‡æ ‡çš„è¯„åˆ†
        hit_rate = np.random.beta(3, 2, n_experiments)
        bleu_score = hit_rate * 0.8 + np.random.normal(0, 0.1, n_experiments)
        bleu_score = np.clip(bleu_score, 0, 1)
        
        latency = 1 - hit_rate * 0.6 + np.random.normal(0, 0.1, n_experiments)
        latency = np.clip(latency, 0.2, 1)
        
        # æ•£ç‚¹å›¾çŸ©é˜µ
        metrics_data = {
            'Hit Rate': hit_rate,
            'BLEU Score': bleu_score,
            'Latency': latency
        }
        
        # Hit Rate vs BLEU Score
        ax3.scatter(hit_rate, bleu_score, alpha=0.6, color='blue')
        
        # è®¡ç®—ç›¸å…³ç³»æ•°
        correlation = np.corrcoef(hit_rate, bleu_score)[0, 1]
        ax3.text(0.05, 0.95, f'ç›¸å…³ç³»æ•°: {correlation:.3f}', 
                transform=ax3.transAxes, fontweight='bold',
                bbox=dict(boxstyle="round,pad=0.3", facecolor='white'))
        
        ax3.set_xlabel('Hit Rate')
        ax3.set_ylabel('BLEU Score')
        ax3.set_title('æ£€ç´¢è´¨é‡ vs ç”Ÿæˆè´¨é‡', fontweight='bold')
        ax3.grid(True, alpha=0.3)
        
        # æ€§èƒ½ä¼˜åŒ–è·¯å¾„
        optimization_stages = {
            'åŸºçº¿ç³»ç»Ÿ': {'æ€§èƒ½': 0.6, 'æˆæœ¬': 0.3, 'å¤æ‚åº¦': 0.2},
            'æ£€ç´¢ä¼˜åŒ–': {'æ€§èƒ½': 0.75, 'æˆæœ¬': 0.5, 'å¤æ‚åº¦': 0.4},
            'ç”Ÿæˆä¼˜åŒ–': {'æ€§èƒ½': 0.85, 'æˆæœ¬': 0.7, 'å¤æ‚åº¦': 0.6},
            'ç«¯åˆ°ç«¯ä¼˜åŒ–': {'æ€§èƒ½': 0.92, 'æˆæœ¬': 0.9, 'å¤æ‚åº¦': 0.8}
        }
        
        stages = list(optimization_stages.keys())
        performance = [optimization_stages[stage]['æ€§èƒ½'] for stage in stages]
        cost = [optimization_stages[stage]['æˆæœ¬'] for stage in stages]
        complexity = [optimization_stages[stage]['å¤æ‚åº¦'] for stage in stages]
        
        # ä¼˜åŒ–è·¯å¾„å›¾
        ax4.plot(cost, performance, 'ro-', linewidth=3, markersize=8, label='æ€§èƒ½æå‡è·¯å¾„')
        
        # æ·»åŠ å¤æ‚åº¦ä¿¡æ¯ï¼ˆæ°”æ³¡å¤§å°ï¼‰
        for i, (stage, perf, c, comp) in enumerate(zip(stages, performance, cost, complexity)):
            ax4.scatter(c, perf, s=comp*500, alpha=0.3, color='blue')
            ax4.annotate(stage, (c, perf), xytext=(5, 5), 
                        textcoords='offset points', fontsize=9)
        
        ax4.set_xlabel('å®æ–½æˆæœ¬')
        ax4.set_ylabel('ç³»ç»Ÿæ€§èƒ½')
        ax4.set_title('RAGä¼˜åŒ–è·¯å¾„åˆ†æ', fontweight='bold')
        ax4.grid(True, alpha=0.3)
        ax4.legend()
        
        plt.tight_layout()
        plt.show()
    
    def analyze_ablation_study(self):
        """åˆ†ææ¶ˆèå®éªŒç»“æœ"""
        # æ¨¡æ‹Ÿæ¶ˆèå®éªŒæ•°æ®
        components = {
            'å®Œæ•´ç³»ç»Ÿ': 0.85,
            'ç§»é™¤æŸ¥è¯¢æ‰©å±•': 0.78,
            'ç§»é™¤é‡æ’åº': 0.75,
            'ç§»é™¤å¤šé˜¶æ®µæ£€ç´¢': 0.70,
            'ä»…å…³é”®è¯æ£€ç´¢': 0.60,
            'ä»…å‘é‡æ£€ç´¢': 0.72
        }
        
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('RAGç³»ç»Ÿæ¶ˆèå®éªŒåˆ†æ', fontsize=16, fontweight='bold')
        
        # ç»„ä»¶è´¡çŒ®åº¦åˆ†æ
        comp_names = list(components.keys())
        comp_scores = list(components.values())
        
        # è®¡ç®—å„ç»„ä»¶çš„è´¡çŒ®åº¦
        baseline_score = components['å®Œæ•´ç³»ç»Ÿ']
        contributions = {}
        for comp in comp_names[1:]:
            if 'ç§»é™¤' in comp:
                contribution = baseline_score - components[comp]
                component_name = comp.replace('ç§»é™¤', '')
                contributions[component_name] = contribution
        
        contrib_names = list(contributions.keys())
        contrib_values = list(contributions.values())
        
        bars = ax1.bar(contrib_names, contrib_values, 
                      color=plt.cm.viridis(np.array(contrib_values)/max(contrib_values)))
        ax1.set_ylabel('æ€§èƒ½è´¡çŒ®åº¦')
        ax1.set_title('å„ç»„ä»¶æ€§èƒ½è´¡çŒ®åˆ†æ', fontweight='bold')
        ax1.tick_params(axis='x', rotation=45)
        
        for bar, value in zip(bars, contrib_values):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + 0.005,
                    f'{value:.3f}', ha='center', va='bottom', fontweight='bold')
        
        # ç³»ç»Ÿé…ç½®å¯¹æ¯”
        bars = ax2.barh(comp_names, comp_scores, 
                       color=plt.cm.plasma(np.array(comp_scores)))
        ax2.set_xlabel('ç³»ç»Ÿæ€§èƒ½')
        ax2.set_title('ä¸åŒé…ç½®æ€§èƒ½å¯¹æ¯”', fontweight='bold')
        
        for bar, score in zip(bars, comp_scores):
            width = bar.get_width()
            ax2.text(width + 0.01, bar.get_y() + bar.get_height()/2,
                    f'{score:.2f}', ha='left', va='center', fontweight='bold')
        
        # æ€§èƒ½vså¤æ‚åº¦æƒè¡¡
        complexity_scores = {
            'å®Œæ•´ç³»ç»Ÿ': 1.0,
            'ç§»é™¤æŸ¥è¯¢æ‰©å±•': 0.8,
            'ç§»é™¤é‡æ’åº': 0.7,
            'ç§»é™¤å¤šé˜¶æ®µæ£€ç´¢': 0.5,
            'ä»…å…³é”®è¯æ£€ç´¢': 0.2,
            'ä»…å‘é‡æ£€ç´¢': 0.4
        }
        
        complexity_values = [complexity_scores[comp] for comp in comp_names]
        
        scatter = ax3.scatter(complexity_values, comp_scores, s=200, 
                            c=range(len(comp_names)), cmap='viridis', alpha=0.7)
        
        for i, comp in enumerate(comp_names):
            ax3.annotate(comp, (complexity_values[i], comp_scores[i]), 
                        xytext=(5, 5), textcoords='offset points', fontsize=8)
        
        ax3.set_xlabel('ç³»ç»Ÿå¤æ‚åº¦')
        ax3.set_ylabel('ç³»ç»Ÿæ€§èƒ½')
        ax3.set_title('æ€§èƒ½-å¤æ‚åº¦æƒè¡¡åˆ†æ', fontweight='bold')
        ax3.grid(True, alpha=0.3)
        
        # ä¼˜åŒ–å»ºè®®å†³ç­–æ ‘
        ax4.set_xlim(0, 10)
        ax4.set_ylim(0, 10)
        ax4.set_title('ç³»ç»Ÿä¼˜åŒ–å†³ç­–æŒ‡å—', fontweight='bold')
        
        # å†³ç­–èŠ‚ç‚¹å’Œå»ºè®®
        decisions = [
            {'text': 'æ€§èƒ½è¦æ±‚', 'pos': (5, 8.5), 'type': 'decision'},
            {'text': 'é«˜æ€§èƒ½éœ€æ±‚', 'pos': (2, 7), 'type': 'decision'},
            {'text': 'ä¸­ç­‰æ€§èƒ½éœ€æ±‚', 'pos': (8, 7), 'type': 'decision'},
            {'text': 'å®Œæ•´ç³»ç»Ÿ\n(0.85)', 'pos': (1, 5.5), 'type': 'result'},
            {'text': 'ç§»é™¤æŸ¥è¯¢æ‰©å±•\n(0.78)', 'pos': (3, 5.5), 'type': 'result'},
            {'text': 'ç§»é™¤é‡æ’åº\n(0.75)', 'pos': (7, 5.5), 'type': 'result'},
            {'text': 'ä»…å‘é‡æ£€ç´¢\n(0.72)', 'pos': (9, 5.5), 'type': 'result'}
        ]
        
        for decision in decisions:
            if decision['type'] == 'decision':
                shape = Circle((decision['pos'][0], decision['pos'][1]), 0.8, 
                              facecolor='lightblue', edgecolor='black')
            else:
                shape = Rectangle((decision['pos'][0]-0.8, decision['pos'][1]-0.6), 
                                1.6, 1.2, facecolor='lightgreen', edgecolor='black')
            
            ax4.add_patch(shape)
            ax4.text(decision['pos'][0], decision['pos'][1], decision['text'],
                    ha='center', va='center', fontsize=9, fontweight='bold')
        
        # è¿æ¥çº¿
        connections = [
            ((5, 7.7), (2, 7.8)),
            ((5, 7.7), (8, 7.8)),
            ((2, 6.2), (1, 6.1)),
            ((2, 6.2), (3, 6.1)),
            ((8, 6.2), (7, 6.1)),
            ((8, 6.2), (9, 6.1))
        ]
        
        for start, end in connections:
            ax4.annotate('', xy=end, xytext=start,
                        arrowprops=dict(arrowstyle='->', lw=1.5, color='red'))
        
        ax4.axis('off')
        
        plt.tight_layout()
        plt.show()
    
    def demonstrate_online_evaluation(self):
        """æ¼”ç¤ºåœ¨çº¿è¯„ä¼°æ–¹æ³•"""
        # æ¨¡æ‹Ÿåœ¨çº¿è¯„ä¼°æ•°æ®
        np.random.seed(42)
        days = 30
        
        # ç”Ÿæˆæ—¶é—´åºåˆ—æ•°æ®
        base_performance = 0.8
        performance_trend = base_performance + 0.1 * np.sin(np.linspace(0, 4*np.pi, days)) + np.random.normal(0, 0.02, days)
        user_satisfaction = performance_trend + np.random.normal(0, 0.05, days)
        query_volume = 1000 + 200 * np.sin(np.linspace(0, 2*np.pi, days)) + np.random.normal(0, 50, days)
        
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig.suptitle('RAGç³»ç»Ÿåœ¨çº¿è¯„ä¼°ç›‘æ§', fontsize=16, fontweight='bold')
        
        # æ€§èƒ½è¶‹åŠ¿ç›‘æ§
        days_range = range(1, days + 1)
        
        ax1.plot(days_range, performance_trend, 'b-o', linewidth=2, 
                markersize=4, label='ç³»ç»Ÿæ€§èƒ½')
        ax1.plot(days_range, user_satisfaction, 'r-s', linewidth=2, 
                markersize=4, label='ç”¨æˆ·æ»¡æ„åº¦')
        
        # æ·»åŠ è¶‹åŠ¿çº¿
        z1 = np.polyfit(days_range, performance_trend, 1)
        p1 = np.poly1d(z1)
        ax1.plot(days_range, p1(days_range), "b--", alpha=0.8, label='æ€§èƒ½è¶‹åŠ¿')
        
        z2 = np.polyfit(days_range, user_satisfaction, 1)
        p2 = np.poly1d(z2)
        ax1.plot(days_range, p2(days_range), "r--", alpha=0.8, label='æ»¡æ„åº¦è¶‹åŠ¿')
        
        ax1.set_xlabel('å¤©æ•°')
        ax1.set_ylabel('è¯„åˆ†')
        ax1.set_title('ç³»ç»Ÿæ€§èƒ½è¶‹åŠ¿ç›‘æ§', fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # æŸ¥è¯¢é‡ä¸æ€§èƒ½å…³ç³»
        ax2.scatter(query_volume, performance_trend, alpha=0.6, color='blue')
        
        # æ‹Ÿåˆå›å½’çº¿
        z = np.polyfit(query_volume, performance_trend, 1)
        p = np.poly1d(z)
        ax2.plot(sorted(query_volume), p(sorted(query_volume)), "r--", alpha=0.8)
        
        correlation = np.corrcoef(query_volume, performance_trend)[0, 1]
        ax2.text(0.05, 0.95, f'ç›¸å…³ç³»æ•°: {correlation:.3f}', 
                transform=ax2.transAxes, fontweight='bold',
                bbox=dict(boxstyle="round,pad=0.3", facecolor='white'))
        
        ax2.set_xlabel('æ—¥æŸ¥è¯¢é‡')
        ax2.set_ylabel('ç³»ç»Ÿæ€§èƒ½')
        ax2.set_title('è´Ÿè½½ä¸æ€§èƒ½å…³ç³»åˆ†æ', fontweight='bold')
        ax2.grid(True, alpha=0.3)
        
        # A/Bæµ‹è¯•ç»“æœ
        ab_test_data = {
            'ç‰ˆæœ¬A (åŸºçº¿)': {'è½¬åŒ–ç‡': 0.12, 'æ»¡æ„åº¦': 0.78, 'å»¶è¿Ÿ': 0.8},
            'ç‰ˆæœ¬B (ä¼˜åŒ–)': {'è½¬åŒ–ç‡': 0.15, 'æ»¡æ„åº¦': 0.85, 'å»¶è¿Ÿ': 0.6}
        }
        
        versions = list(ab_test_data.keys())
        metrics = ['è½¬åŒ–ç‡', 'æ»¡æ„åº¦', 'å»¶è¿Ÿ']
        
        x = np.arange(len(metrics))
        width = 0.35
        
        version_a_values = [ab_test_data['ç‰ˆæœ¬A (åŸºçº¿)'][metric] for metric in metrics]
        version_b_values = [ab_test_data['ç‰ˆæœ¬B (ä¼˜åŒ–)'][metric] for metric in metrics]
        
        bars1 = ax3.bar(x - width/2, version_a_values, width, 
                       label='ç‰ˆæœ¬A (åŸºçº¿)', color='lightcoral', alpha=0.8)
        bars2 = ax3.bar(x + width/2, version_b_values, width, 
                       label='ç‰ˆæœ¬B (ä¼˜åŒ–)', color='lightgreen', alpha=0.8)
        
        ax3.set_xlabel('è¯„ä¼°æŒ‡æ ‡')
        ax3.set_ylabel('è¯„åˆ†')
        ax3.set_title('A/Bæµ‹è¯•ç»“æœå¯¹æ¯”', fontweight='bold')
        ax3.set_xticks(x)
        ax3.set_xticklabels(metrics)
        ax3.legend()
        
        # æ·»åŠ æ•°å€¼æ ‡ç­¾å’Œæå‡ç™¾åˆ†æ¯”
        for i, (bar_a, bar_b, val_a, val_b) in enumerate(zip(bars1, bars2, version_a_values, version_b_values)):
            height_a = bar_a.get_height()
            height_b = bar_b.get_height()
            
            ax3.text(bar_a.get_x() + bar_a.get_width()/2., height_a + 0.01,
                    f'{val_a:.2f}', ha='center', va='bottom', fontweight='bold')
            ax3.text(bar_b.get_x() + bar_b.get_width()/2., height_b + 0.01,
                    f'{val_b:.2f}', ha='center', va='bottom', fontweight='bold')
            
            # è®¡ç®—æå‡ç™¾åˆ†æ¯”ï¼ˆå»¶è¿Ÿæ˜¯è¶Šä½è¶Šå¥½ï¼‰
            if metrics[i] == 'å»¶è¿Ÿ':
                improvement = (val_a - val_b) / val_a * 100
            else:
                improvement = (val_b - val_a) / val_a * 100
            
            ax3.text(i, max(height_a, height_b) + 0.05, f'+{improvement:.1f}%', 
                    ha='center', va='bottom', fontweight='bold', color='green')
        
        # å®æ—¶ç›‘æ§ä»ªè¡¨æ¿
        current_metrics = {
            'ç³»ç»Ÿå¯ç”¨æ€§': 0.995,
            'å¹³å‡å“åº”æ—¶é—´': 0.85,  # å½’ä¸€åŒ–å€¼
            'é”™è¯¯ç‡': 0.02,
            'ç”¨æˆ·æ»¡æ„åº¦': 0.88
        }
        
        # åˆ›å»ºä»ªè¡¨æ¿æ ·å¼çš„å¯è§†åŒ–
        metric_names = list(current_metrics.keys())
        metric_values = list(current_metrics.values())
        
        # ä¸ºé”™è¯¯ç‡åè½¬é¢œè‰²ï¼ˆè¶Šä½è¶Šå¥½ï¼‰
        colors = []
        for i, (name, value) in enumerate(zip(metric_names, metric_values)):
            if name == 'é”™è¯¯ç‡':
                color_value = 1 - value  # åè½¬
            else:
                color_value = value
            
            if color_value >= 0.8:
                colors.append('green')
            elif color_value >= 0.6:
                colors.append('orange')
            else:
                colors.append('red')
        
        bars = ax4.bar(metric_names, metric_values, color=colors, alpha=0.7)
        ax4.set_ylabel('æŒ‡æ ‡å€¼')
        ax4.set_title('å®æ—¶ç³»ç»Ÿç›‘æ§ä»ªè¡¨æ¿', fontweight='bold')
        ax4.tick_params(axis='x', rotation=45)
        ax4.set_ylim(0, 1)
        
        # æ·»åŠ é˜ˆå€¼çº¿
        ax4.axhline(y=0.8, color='orange', linestyle='--', alpha=0.7, label='è­¦å‘Šé˜ˆå€¼')
        ax4.axhline(y=0.6, color='red', linestyle='--', alpha=0.7, label='å±é™©é˜ˆå€¼')
        
        for bar, value in zip(bars, metric_values):
            height = bar.get_height()
            ax4.text(bar.get_x() + bar.get_width()/2., height + 0.02,
                    f'{value:.3f}', ha='center', va='bottom', fontweight='bold')
        
        ax4.legend()
        
        plt.tight_layout()
        plt.show()

# æ¼”ç¤ºRAGè¯„ä¼°åˆ†æ
rag_evaluation = RAGEvaluationAnalyzer()
rag_evaluation.demonstrate_evaluation_framework()
rag_evaluation.analyze_ablation_study()
rag_evaluation.demonstrate_online_evaluation()

print("\n=== RAGè¯„ä¼°ä¼˜åŒ–è¦ç‚¹ ===")
evaluation_concepts = {
    "å¤šç»´è¯„ä¼°": "æ£€ç´¢è´¨é‡ã€ç”Ÿæˆè´¨é‡ã€ç³»ç»Ÿæ€§èƒ½çš„ç»¼åˆè¯„ä¼°",
    "æ¶ˆèå®éªŒ": "é€šè¿‡ç§»é™¤ç»„ä»¶åˆ†æå„éƒ¨åˆ†çš„è´¡çŒ®åº¦",
    "åœ¨çº¿ç›‘æ§": "å®æ—¶è·Ÿè¸ªç³»ç»Ÿæ€§èƒ½å’Œç”¨æˆ·æ»¡æ„åº¦",
    "A/Bæµ‹è¯•": "å¯¹æ¯”ä¸åŒç‰ˆæœ¬çš„å®é™…æ•ˆæœ",
    "æŒç»­ä¼˜åŒ–": "åŸºäºè¯„ä¼°ç»“æœè¿›è¡Œè¿­ä»£æ”¹è¿›"
}

for concept, description in evaluation_concepts.items():
    print(f"â€¢ {concept}: {description}")
```

---

## æœ¬èŠ‚å°ç»“

é€šè¿‡æœ¬èŠ‚çš„å­¦ä¹ ï¼Œæˆ‘ä»¬å…¨é¢æŒæ¡äº†RAGæŠ€æœ¯çš„æ ¸å¿ƒåŸç†å’Œå®è·µæ–¹æ³•ï¼š

### ğŸ¯ æ ¸å¿ƒè¦ç‚¹å›é¡¾

1. **RAGæ¶æ„**: æ·±å…¥ç†è§£æ£€ç´¢-ç”Ÿæˆæ··åˆæ¶æ„çš„è®¾è®¡åŸç†å’Œå·¥ä½œæµç¨‹
2. **å‘é‡æ•°æ®åº“**: æŒæ¡åµŒå…¥æŠ€æœ¯å’Œé«˜æ•ˆå‘é‡å­˜å‚¨æ£€ç´¢æ–¹æ³•
3. **æ£€ç´¢ç­–ç•¥**: å­¦ä¹ å¤šé˜¶æ®µæ£€ç´¢ã€æŸ¥è¯¢æ‰©å±•ã€æ··åˆæœç´¢ç­‰é«˜çº§æŠ€æœ¯
4. **ç³»ç»Ÿè¯„ä¼°**: å»ºç«‹å¤šç»´åº¦è¯„ä¼°ä½“ç³»å’ŒæŒç»­ä¼˜åŒ–æœºåˆ¶

### ğŸ› ï¸ Traeå®è·µè¦ç‚¹

- **æ¶æ„é€‰æ‹©**: æ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©åˆé€‚çš„RAGæ¶æ„å’Œç»„ä»¶
- **æ•°æ®è´¨é‡**: é‡è§†çŸ¥è¯†åº“æ„å»ºå’Œå‘é‡åŒ–çš„è´¨é‡æ§åˆ¶
- **æ£€ç´¢ä¼˜åŒ–**: å¹³è¡¡æ£€ç´¢ç²¾åº¦ã€å¬å›ç‡å’Œè®¡ç®—æ•ˆç‡
- **è¯„ä¼°ç›‘æ§**: å»ºç«‹å®Œå–„çš„è¯„ä¼°æŒ‡æ ‡å’Œåœ¨çº¿ç›‘æ§ä½“ç³»
- **è¿­ä»£æ”¹è¿›**: åŸºäºè¯„ä¼°ç»“æœæŒç»­ä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½

### ğŸ¤” æ·±åº¦æ€è€ƒé¢˜

1. å¦‚ä½•è®¾è®¡RAGç³»ç»Ÿæ¥å¤„ç†å¤šæ¨¡æ€ä¿¡æ¯ï¼ˆæ–‡æœ¬ã€å›¾åƒã€éŸ³é¢‘ï¼‰ï¼Ÿ
2. åœ¨å¤§è§„æ¨¡éƒ¨ç½²ä¸­ï¼Œå¦‚ä½•å¹³è¡¡RAGç³»ç»Ÿçš„å‡†ç¡®æ€§å’Œå®æ—¶æ€§ï¼Ÿ
3. å¦‚ä½•è¯„ä¼°å’Œæé«˜RAGç³»ç»Ÿç”Ÿæˆå†…å®¹çš„äº‹å®å‡†ç¡®æ€§ï¼Ÿ
4. é¢å¯¹çŸ¥è¯†æ›´æ–°é¢‘ç¹çš„é¢†åŸŸï¼Œå¦‚ä½•è®¾è®¡åŠ¨æ€çŸ¥è¯†åº“æ›´æ–°æœºåˆ¶ï¼Ÿ

### ğŸ“š å»¶ä¼¸å­¦ä¹ 

- **å¤šæ¨¡æ€RAG**: æ¢ç´¢å›¾æ–‡ã€éŸ³é¢‘ç­‰å¤šæ¨¡æ€ä¿¡æ¯çš„æ£€ç´¢å¢å¼º
- **å®æ—¶RAG**: ç ”ç©¶æµå¼å¤„ç†å’Œå¢é‡æ›´æ–°æŠ€æœ¯
- **ä¸ªæ€§åŒ–RAG**: å­¦ä¹ ç”¨æˆ·åå¥½å»ºæ¨¡å’Œä¸ªæ€§åŒ–æ£€ç´¢
- **è”é‚¦RAG**: äº†è§£åˆ†å¸ƒå¼çŸ¥è¯†åº“çš„ååŒæ£€ç´¢æ–¹æ³•

---

**ä¸‹ä¸€èŠ‚é¢„å‘Š**: æˆ‘ä»¬å°†å­¦ä¹ ç¬¬ä¸‰ç« çš„æ€»ç»“ï¼Œå›é¡¾å¤§è¯­è¨€æ¨¡å‹è®­ç»ƒä¸ä¼˜åŒ–çš„å®Œæ•´æŠ€æœ¯ä½“ç³»ã€‚